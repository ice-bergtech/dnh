// Code generated by ent, DO NOT EDIT.

package model_ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/asninfo"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/dnsentry"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/domain"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/example"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/ipaddress"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/nameserver"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/path"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/predicate"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/registrar"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/scan"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/scanjob"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/whois"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeASNInfo    = "ASNInfo"
	TypeDNSEntry   = "DNSEntry"
	TypeDomain     = "Domain"
	TypeExample    = "Example"
	TypeIPAddress  = "IPAddress"
	TypeNameserver = "Nameserver"
	TypePath       = "Path"
	TypeRegistrar  = "Registrar"
	TypeScan       = "Scan"
	TypeScanJob    = "ScanJob"
	TypeWhois      = "Whois"
)

// ASNInfoMutation represents an operation that mutates the ASNInfo nodes in the graph.
type ASNInfoMutation struct {
	config
	op               Op
	typ              string
	id               *int
	asn              *int
	addasn           *int
	country          *string
	registry         *string
	clearedFields    map[string]struct{}
	scan             map[int]struct{}
	removedscan      map[int]struct{}
	clearedscan      bool
	ipaddress        map[int]struct{}
	removedipaddress map[int]struct{}
	clearedipaddress bool
	registrar        map[int]struct{}
	removedregistrar map[int]struct{}
	clearedregistrar bool
	whois            map[int]struct{}
	removedwhois     map[int]struct{}
	clearedwhois     bool
	done             bool
	oldValue         func(context.Context) (*ASNInfo, error)
	predicates       []predicate.ASNInfo
}

var _ ent.Mutation = (*ASNInfoMutation)(nil)

// asninfoOption allows management of the mutation configuration using functional options.
type asninfoOption func(*ASNInfoMutation)

// newASNInfoMutation creates new mutation for the ASNInfo entity.
func newASNInfoMutation(c config, op Op, opts ...asninfoOption) *ASNInfoMutation {
	m := &ASNInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeASNInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withASNInfoID sets the ID field of the mutation.
func withASNInfoID(id int) asninfoOption {
	return func(m *ASNInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ASNInfo
		)
		m.oldValue = func(ctx context.Context) (*ASNInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ASNInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withASNInfo sets the old ASNInfo of the mutation.
func withASNInfo(node *ASNInfo) asninfoOption {
	return func(m *ASNInfoMutation) {
		m.oldValue = func(context.Context) (*ASNInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ASNInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ASNInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ASNInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ASNInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ASNInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAsn sets the "asn" field.
func (m *ASNInfoMutation) SetAsn(i int) {
	m.asn = &i
	m.addasn = nil
}

// Asn returns the value of the "asn" field in the mutation.
func (m *ASNInfoMutation) Asn() (r int, exists bool) {
	v := m.asn
	if v == nil {
		return
	}
	return *v, true
}

// OldAsn returns the old "asn" field's value of the ASNInfo entity.
// If the ASNInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASNInfoMutation) OldAsn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsn: %w", err)
	}
	return oldValue.Asn, nil
}

// AddAsn adds i to the "asn" field.
func (m *ASNInfoMutation) AddAsn(i int) {
	if m.addasn != nil {
		*m.addasn += i
	} else {
		m.addasn = &i
	}
}

// AddedAsn returns the value that was added to the "asn" field in this mutation.
func (m *ASNInfoMutation) AddedAsn() (r int, exists bool) {
	v := m.addasn
	if v == nil {
		return
	}
	return *v, true
}

// ResetAsn resets all changes to the "asn" field.
func (m *ASNInfoMutation) ResetAsn() {
	m.asn = nil
	m.addasn = nil
}

// SetCountry sets the "country" field.
func (m *ASNInfoMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *ASNInfoMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the ASNInfo entity.
// If the ASNInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASNInfoMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *ASNInfoMutation) ResetCountry() {
	m.country = nil
}

// SetRegistry sets the "registry" field.
func (m *ASNInfoMutation) SetRegistry(s string) {
	m.registry = &s
}

// Registry returns the value of the "registry" field in the mutation.
func (m *ASNInfoMutation) Registry() (r string, exists bool) {
	v := m.registry
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistry returns the old "registry" field's value of the ASNInfo entity.
// If the ASNInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ASNInfoMutation) OldRegistry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistry: %w", err)
	}
	return oldValue.Registry, nil
}

// ResetRegistry resets all changes to the "registry" field.
func (m *ASNInfoMutation) ResetRegistry() {
	m.registry = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *ASNInfoMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *ASNInfoMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *ASNInfoMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *ASNInfoMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *ASNInfoMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *ASNInfoMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *ASNInfoMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *ASNInfoMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *ASNInfoMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *ASNInfoMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *ASNInfoMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *ASNInfoMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *ASNInfoMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *ASNInfoMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *ASNInfoMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *ASNInfoMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *ASNInfoMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *ASNInfoMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *ASNInfoMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *ASNInfoMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *ASNInfoMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *ASNInfoMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *ASNInfoMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *ASNInfoMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *ASNInfoMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *ASNInfoMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *ASNInfoMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *ASNInfoMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the ASNInfoMutation builder.
func (m *ASNInfoMutation) Where(ps ...predicate.ASNInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ASNInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ASNInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ASNInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ASNInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ASNInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ASNInfo).
func (m *ASNInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ASNInfoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.asn != nil {
		fields = append(fields, asninfo.FieldAsn)
	}
	if m.country != nil {
		fields = append(fields, asninfo.FieldCountry)
	}
	if m.registry != nil {
		fields = append(fields, asninfo.FieldRegistry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ASNInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asninfo.FieldAsn:
		return m.Asn()
	case asninfo.FieldCountry:
		return m.Country()
	case asninfo.FieldRegistry:
		return m.Registry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ASNInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asninfo.FieldAsn:
		return m.OldAsn(ctx)
	case asninfo.FieldCountry:
		return m.OldCountry(ctx)
	case asninfo.FieldRegistry:
		return m.OldRegistry(ctx)
	}
	return nil, fmt.Errorf("unknown ASNInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ASNInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asninfo.FieldAsn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsn(v)
		return nil
	case asninfo.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case asninfo.FieldRegistry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistry(v)
		return nil
	}
	return fmt.Errorf("unknown ASNInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ASNInfoMutation) AddedFields() []string {
	var fields []string
	if m.addasn != nil {
		fields = append(fields, asninfo.FieldAsn)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ASNInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asninfo.FieldAsn:
		return m.AddedAsn()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ASNInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asninfo.FieldAsn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAsn(v)
		return nil
	}
	return fmt.Errorf("unknown ASNInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ASNInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ASNInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ASNInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ASNInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ASNInfoMutation) ResetField(name string) error {
	switch name {
	case asninfo.FieldAsn:
		m.ResetAsn()
		return nil
	case asninfo.FieldCountry:
		m.ResetCountry()
		return nil
	case asninfo.FieldRegistry:
		m.ResetRegistry()
		return nil
	}
	return fmt.Errorf("unknown ASNInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ASNInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.scan != nil {
		edges = append(edges, asninfo.EdgeScan)
	}
	if m.ipaddress != nil {
		edges = append(edges, asninfo.EdgeIpaddress)
	}
	if m.registrar != nil {
		edges = append(edges, asninfo.EdgeRegistrar)
	}
	if m.whois != nil {
		edges = append(edges, asninfo.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ASNInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asninfo.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ASNInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedscan != nil {
		edges = append(edges, asninfo.EdgeScan)
	}
	if m.removedipaddress != nil {
		edges = append(edges, asninfo.EdgeIpaddress)
	}
	if m.removedregistrar != nil {
		edges = append(edges, asninfo.EdgeRegistrar)
	}
	if m.removedwhois != nil {
		edges = append(edges, asninfo.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ASNInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asninfo.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case asninfo.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ASNInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedscan {
		edges = append(edges, asninfo.EdgeScan)
	}
	if m.clearedipaddress {
		edges = append(edges, asninfo.EdgeIpaddress)
	}
	if m.clearedregistrar {
		edges = append(edges, asninfo.EdgeRegistrar)
	}
	if m.clearedwhois {
		edges = append(edges, asninfo.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ASNInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case asninfo.EdgeScan:
		return m.clearedscan
	case asninfo.EdgeIpaddress:
		return m.clearedipaddress
	case asninfo.EdgeRegistrar:
		return m.clearedregistrar
	case asninfo.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ASNInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ASNInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ASNInfoMutation) ResetEdge(name string) error {
	switch name {
	case asninfo.EdgeScan:
		m.ResetScan()
		return nil
	case asninfo.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case asninfo.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case asninfo.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown ASNInfo edge %s", name)
}

// DNSEntryMutation represents an operation that mutates the DNSEntry nodes in the graph.
type DNSEntryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	_type             *string
	value             *string
	ttl               *int
	addttl            *int
	time_first        *time.Time
	time_last         *time.Time
	clearedFields     map[string]struct{}
	domain            map[int]struct{}
	removeddomain     map[int]struct{}
	cleareddomain     bool
	ipaddress         map[int]struct{}
	removedipaddress  map[int]struct{}
	clearedipaddress  bool
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	scan              map[int]struct{}
	removedscan       map[int]struct{}
	clearedscan       bool
	done              bool
	oldValue          func(context.Context) (*DNSEntry, error)
	predicates        []predicate.DNSEntry
}

var _ ent.Mutation = (*DNSEntryMutation)(nil)

// dnsentryOption allows management of the mutation configuration using functional options.
type dnsentryOption func(*DNSEntryMutation)

// newDNSEntryMutation creates new mutation for the DNSEntry entity.
func newDNSEntryMutation(c config, op Op, opts ...dnsentryOption) *DNSEntryMutation {
	m := &DNSEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSEntryID sets the ID field of the mutation.
func withDNSEntryID(id int) dnsentryOption {
	return func(m *DNSEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSEntry
		)
		m.oldValue = func(ctx context.Context) (*DNSEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSEntry sets the old DNSEntry of the mutation.
func withDNSEntry(node *DNSEntry) dnsentryOption {
	return func(m *DNSEntryMutation) {
		m.oldValue = func(context.Context) (*DNSEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DNSEntryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSEntryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSEntryMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *DNSEntryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSEntryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSEntryMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *DNSEntryMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DNSEntryMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DNSEntryMutation) ResetValue() {
	m.value = nil
}

// SetTTL sets the "ttl" field.
func (m *DNSEntryMutation) SetTTL(i int) {
	m.ttl = &i
	m.addttl = nil
}

// TTL returns the value of the "ttl" field in the mutation.
func (m *DNSEntryMutation) TTL() (r int, exists bool) {
	v := m.ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldTTL returns the old "ttl" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldTTL(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTL: %w", err)
	}
	return oldValue.TTL, nil
}

// AddTTL adds i to the "ttl" field.
func (m *DNSEntryMutation) AddTTL(i int) {
	if m.addttl != nil {
		*m.addttl += i
	} else {
		m.addttl = &i
	}
}

// AddedTTL returns the value that was added to the "ttl" field in this mutation.
func (m *DNSEntryMutation) AddedTTL() (r int, exists bool) {
	v := m.addttl
	if v == nil {
		return
	}
	return *v, true
}

// ResetTTL resets all changes to the "ttl" field.
func (m *DNSEntryMutation) ResetTTL() {
	m.ttl = nil
	m.addttl = nil
}

// SetTimeFirst sets the "time_first" field.
func (m *DNSEntryMutation) SetTimeFirst(t time.Time) {
	m.time_first = &t
}

// TimeFirst returns the value of the "time_first" field in the mutation.
func (m *DNSEntryMutation) TimeFirst() (r time.Time, exists bool) {
	v := m.time_first
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFirst returns the old "time_first" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldTimeFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFirst: %w", err)
	}
	return oldValue.TimeFirst, nil
}

// ResetTimeFirst resets all changes to the "time_first" field.
func (m *DNSEntryMutation) ResetTimeFirst() {
	m.time_first = nil
}

// SetTimeLast sets the "time_last" field.
func (m *DNSEntryMutation) SetTimeLast(t time.Time) {
	m.time_last = &t
}

// TimeLast returns the value of the "time_last" field in the mutation.
func (m *DNSEntryMutation) TimeLast() (r time.Time, exists bool) {
	v := m.time_last
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLast returns the old "time_last" field's value of the DNSEntry entity.
// If the DNSEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSEntryMutation) OldTimeLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLast: %w", err)
	}
	return oldValue.TimeLast, nil
}

// ResetTimeLast resets all changes to the "time_last" field.
func (m *DNSEntryMutation) ResetTimeLast() {
	m.time_last = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *DNSEntryMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *DNSEntryMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *DNSEntryMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *DNSEntryMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *DNSEntryMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *DNSEntryMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *DNSEntryMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *DNSEntryMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *DNSEntryMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *DNSEntryMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *DNSEntryMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *DNSEntryMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *DNSEntryMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *DNSEntryMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *DNSEntryMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *DNSEntryMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *DNSEntryMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *DNSEntryMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *DNSEntryMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *DNSEntryMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *DNSEntryMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *DNSEntryMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *DNSEntryMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *DNSEntryMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *DNSEntryMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *DNSEntryMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *DNSEntryMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *DNSEntryMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// Where appends a list predicates to the DNSEntryMutation builder.
func (m *DNSEntryMutation) Where(ps ...predicate.DNSEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DNSEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DNSEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DNSEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DNSEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DNSEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DNSEntry).
func (m *DNSEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSEntryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, dnsentry.FieldName)
	}
	if m._type != nil {
		fields = append(fields, dnsentry.FieldType)
	}
	if m.value != nil {
		fields = append(fields, dnsentry.FieldValue)
	}
	if m.ttl != nil {
		fields = append(fields, dnsentry.FieldTTL)
	}
	if m.time_first != nil {
		fields = append(fields, dnsentry.FieldTimeFirst)
	}
	if m.time_last != nil {
		fields = append(fields, dnsentry.FieldTimeLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsentry.FieldName:
		return m.Name()
	case dnsentry.FieldType:
		return m.GetType()
	case dnsentry.FieldValue:
		return m.Value()
	case dnsentry.FieldTTL:
		return m.TTL()
	case dnsentry.FieldTimeFirst:
		return m.TimeFirst()
	case dnsentry.FieldTimeLast:
		return m.TimeLast()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsentry.FieldName:
		return m.OldName(ctx)
	case dnsentry.FieldType:
		return m.OldType(ctx)
	case dnsentry.FieldValue:
		return m.OldValue(ctx)
	case dnsentry.FieldTTL:
		return m.OldTTL(ctx)
	case dnsentry.FieldTimeFirst:
		return m.OldTimeFirst(ctx)
	case dnsentry.FieldTimeLast:
		return m.OldTimeLast(ctx)
	}
	return nil, fmt.Errorf("unknown DNSEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsentry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsentry.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsentry.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dnsentry.FieldTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTL(v)
		return nil
	case dnsentry.FieldTimeFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFirst(v)
		return nil
	case dnsentry.FieldTimeLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLast(v)
		return nil
	}
	return fmt.Errorf("unknown DNSEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSEntryMutation) AddedFields() []string {
	var fields []string
	if m.addttl != nil {
		fields = append(fields, dnsentry.FieldTTL)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dnsentry.FieldTTL:
		return m.AddedTTL()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dnsentry.FieldTTL:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTTL(v)
		return nil
	}
	return fmt.Errorf("unknown DNSEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSEntryMutation) ResetField(name string) error {
	switch name {
	case dnsentry.FieldName:
		m.ResetName()
		return nil
	case dnsentry.FieldType:
		m.ResetType()
		return nil
	case dnsentry.FieldValue:
		m.ResetValue()
		return nil
	case dnsentry.FieldTTL:
		m.ResetTTL()
		return nil
	case dnsentry.FieldTimeFirst:
		m.ResetTimeFirst()
		return nil
	case dnsentry.FieldTimeLast:
		m.ResetTimeLast()
		return nil
	}
	return fmt.Errorf("unknown DNSEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.domain != nil {
		edges = append(edges, dnsentry.EdgeDomain)
	}
	if m.ipaddress != nil {
		edges = append(edges, dnsentry.EdgeIpaddress)
	}
	if m.nameserver != nil {
		edges = append(edges, dnsentry.EdgeNameserver)
	}
	if m.scan != nil {
		edges = append(edges, dnsentry.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsentry.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddomain != nil {
		edges = append(edges, dnsentry.EdgeDomain)
	}
	if m.removedipaddress != nil {
		edges = append(edges, dnsentry.EdgeIpaddress)
	}
	if m.removednameserver != nil {
		edges = append(edges, dnsentry.EdgeNameserver)
	}
	if m.removedscan != nil {
		edges = append(edges, dnsentry.EdgeScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dnsentry.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case dnsentry.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddomain {
		edges = append(edges, dnsentry.EdgeDomain)
	}
	if m.clearedipaddress {
		edges = append(edges, dnsentry.EdgeIpaddress)
	}
	if m.clearednameserver {
		edges = append(edges, dnsentry.EdgeNameserver)
	}
	if m.clearedscan {
		edges = append(edges, dnsentry.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsentry.EdgeDomain:
		return m.cleareddomain
	case dnsentry.EdgeIpaddress:
		return m.clearedipaddress
	case dnsentry.EdgeNameserver:
		return m.clearednameserver
	case dnsentry.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSEntryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSEntryMutation) ResetEdge(name string) error {
	switch name {
	case dnsentry.EdgeDomain:
		m.ResetDomain()
		return nil
	case dnsentry.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case dnsentry.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case dnsentry.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown DNSEntry edge %s", name)
}

// DomainMutation represents an operation that mutates the Domain nodes in the graph.
type DomainMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	ports             *[]int
	appendports       []int
	time_first        *time.Time
	time_last         *time.Time
	clearedFields     map[string]struct{}
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	subdomain         map[int]struct{}
	removedsubdomain  map[int]struct{}
	clearedsubdomain  bool
	ipaddress         map[int]struct{}
	removedipaddress  map[int]struct{}
	clearedipaddress  bool
	_path             map[int]struct{}
	removed_path      map[int]struct{}
	cleared_path      bool
	scan              map[int]struct{}
	removedscan       map[int]struct{}
	clearedscan       bool
	dnsentry          map[int]struct{}
	removeddnsentry   map[int]struct{}
	cleareddnsentry   bool
	registrar         map[int]struct{}
	removedregistrar  map[int]struct{}
	clearedregistrar  bool
	whois             map[int]struct{}
	removedwhois      map[int]struct{}
	clearedwhois      bool
	done              bool
	oldValue          func(context.Context) (*Domain, error)
	predicates        []predicate.Domain
}

var _ ent.Mutation = (*DomainMutation)(nil)

// domainOption allows management of the mutation configuration using functional options.
type domainOption func(*DomainMutation)

// newDomainMutation creates new mutation for the Domain entity.
func newDomainMutation(c config, op Op, opts ...domainOption) *DomainMutation {
	m := &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainID sets the ID field of the mutation.
func withDomainID(id int) domainOption {
	return func(m *DomainMutation) {
		var (
			err   error
			once  sync.Once
			value *Domain
		)
		m.oldValue = func(ctx context.Context) (*Domain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Domain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomain sets the old Domain of the mutation.
func withDomain(node *Domain) domainOption {
	return func(m *DomainMutation) {
		m.oldValue = func(context.Context) (*Domain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Domain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DomainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DomainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DomainMutation) ResetName() {
	m.name = nil
}

// SetPorts sets the "ports" field.
func (m *DomainMutation) SetPorts(i []int) {
	m.ports = &i
	m.appendports = nil
}

// Ports returns the value of the "ports" field in the mutation.
func (m *DomainMutation) Ports() (r []int, exists bool) {
	v := m.ports
	if v == nil {
		return
	}
	return *v, true
}

// OldPorts returns the old "ports" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldPorts(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorts: %w", err)
	}
	return oldValue.Ports, nil
}

// AppendPorts adds i to the "ports" field.
func (m *DomainMutation) AppendPorts(i []int) {
	m.appendports = append(m.appendports, i...)
}

// AppendedPorts returns the list of values that were appended to the "ports" field in this mutation.
func (m *DomainMutation) AppendedPorts() ([]int, bool) {
	if len(m.appendports) == 0 {
		return nil, false
	}
	return m.appendports, true
}

// ResetPorts resets all changes to the "ports" field.
func (m *DomainMutation) ResetPorts() {
	m.ports = nil
	m.appendports = nil
}

// SetTimeFirst sets the "time_first" field.
func (m *DomainMutation) SetTimeFirst(t time.Time) {
	m.time_first = &t
}

// TimeFirst returns the value of the "time_first" field in the mutation.
func (m *DomainMutation) TimeFirst() (r time.Time, exists bool) {
	v := m.time_first
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFirst returns the old "time_first" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldTimeFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFirst: %w", err)
	}
	return oldValue.TimeFirst, nil
}

// ResetTimeFirst resets all changes to the "time_first" field.
func (m *DomainMutation) ResetTimeFirst() {
	m.time_first = nil
}

// SetTimeLast sets the "time_last" field.
func (m *DomainMutation) SetTimeLast(t time.Time) {
	m.time_last = &t
}

// TimeLast returns the value of the "time_last" field in the mutation.
func (m *DomainMutation) TimeLast() (r time.Time, exists bool) {
	v := m.time_last
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLast returns the old "time_last" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldTimeLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLast: %w", err)
	}
	return oldValue.TimeLast, nil
}

// ResetTimeLast resets all changes to the "time_last" field.
func (m *DomainMutation) ResetTimeLast() {
	m.time_last = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *DomainMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *DomainMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *DomainMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *DomainMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *DomainMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *DomainMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *DomainMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddSubdomainIDs adds the "subdomain" edge to the Domain entity by ids.
func (m *DomainMutation) AddSubdomainIDs(ids ...int) {
	if m.subdomain == nil {
		m.subdomain = make(map[int]struct{})
	}
	for i := range ids {
		m.subdomain[ids[i]] = struct{}{}
	}
}

// ClearSubdomain clears the "subdomain" edge to the Domain entity.
func (m *DomainMutation) ClearSubdomain() {
	m.clearedsubdomain = true
}

// SubdomainCleared reports if the "subdomain" edge to the Domain entity was cleared.
func (m *DomainMutation) SubdomainCleared() bool {
	return m.clearedsubdomain
}

// RemoveSubdomainIDs removes the "subdomain" edge to the Domain entity by IDs.
func (m *DomainMutation) RemoveSubdomainIDs(ids ...int) {
	if m.removedsubdomain == nil {
		m.removedsubdomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subdomain, ids[i])
		m.removedsubdomain[ids[i]] = struct{}{}
	}
}

// RemovedSubdomain returns the removed IDs of the "subdomain" edge to the Domain entity.
func (m *DomainMutation) RemovedSubdomainIDs() (ids []int) {
	for id := range m.removedsubdomain {
		ids = append(ids, id)
	}
	return
}

// SubdomainIDs returns the "subdomain" edge IDs in the mutation.
func (m *DomainMutation) SubdomainIDs() (ids []int) {
	for id := range m.subdomain {
		ids = append(ids, id)
	}
	return
}

// ResetSubdomain resets all changes to the "subdomain" edge.
func (m *DomainMutation) ResetSubdomain() {
	m.subdomain = nil
	m.clearedsubdomain = false
	m.removedsubdomain = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *DomainMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *DomainMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *DomainMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *DomainMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *DomainMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *DomainMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *DomainMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddPathIDs adds the "path" edge to the Path entity by ids.
func (m *DomainMutation) AddPathIDs(ids ...int) {
	if m._path == nil {
		m._path = make(map[int]struct{})
	}
	for i := range ids {
		m._path[ids[i]] = struct{}{}
	}
}

// ClearPath clears the "path" edge to the Path entity.
func (m *DomainMutation) ClearPath() {
	m.cleared_path = true
}

// PathCleared reports if the "path" edge to the Path entity was cleared.
func (m *DomainMutation) PathCleared() bool {
	return m.cleared_path
}

// RemovePathIDs removes the "path" edge to the Path entity by IDs.
func (m *DomainMutation) RemovePathIDs(ids ...int) {
	if m.removed_path == nil {
		m.removed_path = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._path, ids[i])
		m.removed_path[ids[i]] = struct{}{}
	}
}

// RemovedPath returns the removed IDs of the "path" edge to the Path entity.
func (m *DomainMutation) RemovedPathIDs() (ids []int) {
	for id := range m.removed_path {
		ids = append(ids, id)
	}
	return
}

// PathIDs returns the "path" edge IDs in the mutation.
func (m *DomainMutation) PathIDs() (ids []int) {
	for id := range m._path {
		ids = append(ids, id)
	}
	return
}

// ResetPath resets all changes to the "path" edge.
func (m *DomainMutation) ResetPath() {
	m._path = nil
	m.cleared_path = false
	m.removed_path = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *DomainMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *DomainMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *DomainMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *DomainMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *DomainMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *DomainMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *DomainMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddDnsentryIDs adds the "dnsentry" edge to the DNSEntry entity by ids.
func (m *DomainMutation) AddDnsentryIDs(ids ...int) {
	if m.dnsentry == nil {
		m.dnsentry = make(map[int]struct{})
	}
	for i := range ids {
		m.dnsentry[ids[i]] = struct{}{}
	}
}

// ClearDnsentry clears the "dnsentry" edge to the DNSEntry entity.
func (m *DomainMutation) ClearDnsentry() {
	m.cleareddnsentry = true
}

// DnsentryCleared reports if the "dnsentry" edge to the DNSEntry entity was cleared.
func (m *DomainMutation) DnsentryCleared() bool {
	return m.cleareddnsentry
}

// RemoveDnsentryIDs removes the "dnsentry" edge to the DNSEntry entity by IDs.
func (m *DomainMutation) RemoveDnsentryIDs(ids ...int) {
	if m.removeddnsentry == nil {
		m.removeddnsentry = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dnsentry, ids[i])
		m.removeddnsentry[ids[i]] = struct{}{}
	}
}

// RemovedDnsentry returns the removed IDs of the "dnsentry" edge to the DNSEntry entity.
func (m *DomainMutation) RemovedDnsentryIDs() (ids []int) {
	for id := range m.removeddnsentry {
		ids = append(ids, id)
	}
	return
}

// DnsentryIDs returns the "dnsentry" edge IDs in the mutation.
func (m *DomainMutation) DnsentryIDs() (ids []int) {
	for id := range m.dnsentry {
		ids = append(ids, id)
	}
	return
}

// ResetDnsentry resets all changes to the "dnsentry" edge.
func (m *DomainMutation) ResetDnsentry() {
	m.dnsentry = nil
	m.cleareddnsentry = false
	m.removeddnsentry = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *DomainMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *DomainMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *DomainMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *DomainMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *DomainMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *DomainMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *DomainMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *DomainMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *DomainMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *DomainMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *DomainMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *DomainMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *DomainMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *DomainMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the DomainMutation builder.
func (m *DomainMutation) Where(ps ...predicate.Domain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Domain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, domain.FieldName)
	}
	if m.ports != nil {
		fields = append(fields, domain.FieldPorts)
	}
	if m.time_first != nil {
		fields = append(fields, domain.FieldTimeFirst)
	}
	if m.time_last != nil {
		fields = append(fields, domain.FieldTimeLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldName:
		return m.Name()
	case domain.FieldPorts:
		return m.Ports()
	case domain.FieldTimeFirst:
		return m.TimeFirst()
	case domain.FieldTimeLast:
		return m.TimeLast()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domain.FieldName:
		return m.OldName(ctx)
	case domain.FieldPorts:
		return m.OldPorts(ctx)
	case domain.FieldTimeFirst:
		return m.OldTimeFirst(ctx)
	case domain.FieldTimeLast:
		return m.OldTimeLast(ctx)
	}
	return nil, fmt.Errorf("unknown Domain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case domain.FieldPorts:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorts(v)
		return nil
	case domain.FieldTimeFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFirst(v)
		return nil
	case domain.FieldTimeLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLast(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldName:
		m.ResetName()
		return nil
	case domain.FieldPorts:
		m.ResetPorts()
		return nil
	case domain.FieldTimeFirst:
		m.ResetTimeFirst()
		return nil
	case domain.FieldTimeLast:
		m.ResetTimeLast()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.nameserver != nil {
		edges = append(edges, domain.EdgeNameserver)
	}
	if m.subdomain != nil {
		edges = append(edges, domain.EdgeSubdomain)
	}
	if m.ipaddress != nil {
		edges = append(edges, domain.EdgeIpaddress)
	}
	if m._path != nil {
		edges = append(edges, domain.EdgePath)
	}
	if m.scan != nil {
		edges = append(edges, domain.EdgeScan)
	}
	if m.dnsentry != nil {
		edges = append(edges, domain.EdgeDnsentry)
	}
	if m.registrar != nil {
		edges = append(edges, domain.EdgeRegistrar)
	}
	if m.whois != nil {
		edges = append(edges, domain.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeSubdomain:
		ids := make([]ent.Value, 0, len(m.subdomain))
		for id := range m.subdomain {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgePath:
		ids := make([]ent.Value, 0, len(m._path))
		for id := range m._path {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.dnsentry))
		for id := range m.dnsentry {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removednameserver != nil {
		edges = append(edges, domain.EdgeNameserver)
	}
	if m.removedsubdomain != nil {
		edges = append(edges, domain.EdgeSubdomain)
	}
	if m.removedipaddress != nil {
		edges = append(edges, domain.EdgeIpaddress)
	}
	if m.removed_path != nil {
		edges = append(edges, domain.EdgePath)
	}
	if m.removedscan != nil {
		edges = append(edges, domain.EdgeScan)
	}
	if m.removeddnsentry != nil {
		edges = append(edges, domain.EdgeDnsentry)
	}
	if m.removedregistrar != nil {
		edges = append(edges, domain.EdgeRegistrar)
	}
	if m.removedwhois != nil {
		edges = append(edges, domain.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeSubdomain:
		ids := make([]ent.Value, 0, len(m.removedsubdomain))
		for id := range m.removedsubdomain {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgePath:
		ids := make([]ent.Value, 0, len(m.removed_path))
		for id := range m.removed_path {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.removeddnsentry))
		for id := range m.removeddnsentry {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearednameserver {
		edges = append(edges, domain.EdgeNameserver)
	}
	if m.clearedsubdomain {
		edges = append(edges, domain.EdgeSubdomain)
	}
	if m.clearedipaddress {
		edges = append(edges, domain.EdgeIpaddress)
	}
	if m.cleared_path {
		edges = append(edges, domain.EdgePath)
	}
	if m.clearedscan {
		edges = append(edges, domain.EdgeScan)
	}
	if m.cleareddnsentry {
		edges = append(edges, domain.EdgeDnsentry)
	}
	if m.clearedregistrar {
		edges = append(edges, domain.EdgeRegistrar)
	}
	if m.clearedwhois {
		edges = append(edges, domain.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	case domain.EdgeNameserver:
		return m.clearednameserver
	case domain.EdgeSubdomain:
		return m.clearedsubdomain
	case domain.EdgeIpaddress:
		return m.clearedipaddress
	case domain.EdgePath:
		return m.cleared_path
	case domain.EdgeScan:
		return m.clearedscan
	case domain.EdgeDnsentry:
		return m.cleareddnsentry
	case domain.EdgeRegistrar:
		return m.clearedregistrar
	case domain.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case domain.EdgeSubdomain:
		m.ResetSubdomain()
		return nil
	case domain.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case domain.EdgePath:
		m.ResetPath()
		return nil
	case domain.EdgeScan:
		m.ResetScan()
		return nil
	case domain.EdgeDnsentry:
		m.ResetDnsentry()
		return nil
	case domain.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case domain.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// ExampleMutation represents an operation that mutates the Example nodes in the graph.
type ExampleMutation struct {
	config
	op                Op
	typ               string
	id                *string
	timestamp         *time.Time
	clearedFields     map[string]struct{}
	ipaddress         *int
	clearedipaddress  bool
	next              map[int]struct{}
	removednext       map[int]struct{}
	clearednext       bool
	dnsentry          map[int]struct{}
	removeddnsentry   map[int]struct{}
	cleareddnsentry   bool
	domain            map[int]struct{}
	removeddomain     map[int]struct{}
	cleareddomain     bool
	paths             map[int]struct{}
	removedpaths      map[int]struct{}
	clearedpaths      bool
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	registrar         map[int]struct{}
	removedregistrar  map[int]struct{}
	clearedregistrar  bool
	whois             map[int]struct{}
	removedwhois      map[int]struct{}
	clearedwhois      bool
	done              bool
	oldValue          func(context.Context) (*Example, error)
	predicates        []predicate.Example
}

var _ ent.Mutation = (*ExampleMutation)(nil)

// exampleOption allows management of the mutation configuration using functional options.
type exampleOption func(*ExampleMutation)

// newExampleMutation creates new mutation for the Example entity.
func newExampleMutation(c config, op Op, opts ...exampleOption) *ExampleMutation {
	m := &ExampleMutation{
		config:        c,
		op:            op,
		typ:           TypeExample,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExampleID sets the ID field of the mutation.
func withExampleID(id string) exampleOption {
	return func(m *ExampleMutation) {
		var (
			err   error
			once  sync.Once
			value *Example
		)
		m.oldValue = func(ctx context.Context) (*Example, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Example.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExample sets the old Example of the mutation.
func withExample(node *Example) exampleOption {
	return func(m *ExampleMutation) {
		m.oldValue = func(context.Context) (*Example, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExampleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExampleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Example entities.
func (m *ExampleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExampleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExampleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Example.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *ExampleMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ExampleMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Example entity.
// If the Example object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExampleMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ExampleMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetIpaddressID sets the "ipaddress" edge to the IPAddress entity by id.
func (m *ExampleMutation) SetIpaddressID(id int) {
	m.ipaddress = &id
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *ExampleMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *ExampleMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// IpaddressID returns the "ipaddress" edge ID in the mutation.
func (m *ExampleMutation) IpaddressID() (id int, exists bool) {
	if m.ipaddress != nil {
		return *m.ipaddress, true
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IpaddressID instead. It exists only for internal usage by the builders.
func (m *ExampleMutation) IpaddressIDs() (ids []int) {
	if id := m.ipaddress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *ExampleMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
}

// AddNextIDs adds the "next" edge to the ASNInfo entity by ids.
func (m *ExampleMutation) AddNextIDs(ids ...int) {
	if m.next == nil {
		m.next = make(map[int]struct{})
	}
	for i := range ids {
		m.next[ids[i]] = struct{}{}
	}
}

// ClearNext clears the "next" edge to the ASNInfo entity.
func (m *ExampleMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the ASNInfo entity was cleared.
func (m *ExampleMutation) NextCleared() bool {
	return m.clearednext
}

// RemoveNextIDs removes the "next" edge to the ASNInfo entity by IDs.
func (m *ExampleMutation) RemoveNextIDs(ids ...int) {
	if m.removednext == nil {
		m.removednext = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.next, ids[i])
		m.removednext[ids[i]] = struct{}{}
	}
}

// RemovedNext returns the removed IDs of the "next" edge to the ASNInfo entity.
func (m *ExampleMutation) RemovedNextIDs() (ids []int) {
	for id := range m.removednext {
		ids = append(ids, id)
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
func (m *ExampleMutation) NextIDs() (ids []int) {
	for id := range m.next {
		ids = append(ids, id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *ExampleMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
	m.removednext = nil
}

// AddDnsentryIDs adds the "dnsentry" edge to the DNSEntry entity by ids.
func (m *ExampleMutation) AddDnsentryIDs(ids ...int) {
	if m.dnsentry == nil {
		m.dnsentry = make(map[int]struct{})
	}
	for i := range ids {
		m.dnsentry[ids[i]] = struct{}{}
	}
}

// ClearDnsentry clears the "dnsentry" edge to the DNSEntry entity.
func (m *ExampleMutation) ClearDnsentry() {
	m.cleareddnsentry = true
}

// DnsentryCleared reports if the "dnsentry" edge to the DNSEntry entity was cleared.
func (m *ExampleMutation) DnsentryCleared() bool {
	return m.cleareddnsentry
}

// RemoveDnsentryIDs removes the "dnsentry" edge to the DNSEntry entity by IDs.
func (m *ExampleMutation) RemoveDnsentryIDs(ids ...int) {
	if m.removeddnsentry == nil {
		m.removeddnsentry = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dnsentry, ids[i])
		m.removeddnsentry[ids[i]] = struct{}{}
	}
}

// RemovedDnsentry returns the removed IDs of the "dnsentry" edge to the DNSEntry entity.
func (m *ExampleMutation) RemovedDnsentryIDs() (ids []int) {
	for id := range m.removeddnsentry {
		ids = append(ids, id)
	}
	return
}

// DnsentryIDs returns the "dnsentry" edge IDs in the mutation.
func (m *ExampleMutation) DnsentryIDs() (ids []int) {
	for id := range m.dnsentry {
		ids = append(ids, id)
	}
	return
}

// ResetDnsentry resets all changes to the "dnsentry" edge.
func (m *ExampleMutation) ResetDnsentry() {
	m.dnsentry = nil
	m.cleareddnsentry = false
	m.removeddnsentry = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *ExampleMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *ExampleMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *ExampleMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *ExampleMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *ExampleMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *ExampleMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *ExampleMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddPathIDs adds the "paths" edge to the Path entity by ids.
func (m *ExampleMutation) AddPathIDs(ids ...int) {
	if m.paths == nil {
		m.paths = make(map[int]struct{})
	}
	for i := range ids {
		m.paths[ids[i]] = struct{}{}
	}
}

// ClearPaths clears the "paths" edge to the Path entity.
func (m *ExampleMutation) ClearPaths() {
	m.clearedpaths = true
}

// PathsCleared reports if the "paths" edge to the Path entity was cleared.
func (m *ExampleMutation) PathsCleared() bool {
	return m.clearedpaths
}

// RemovePathIDs removes the "paths" edge to the Path entity by IDs.
func (m *ExampleMutation) RemovePathIDs(ids ...int) {
	if m.removedpaths == nil {
		m.removedpaths = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.paths, ids[i])
		m.removedpaths[ids[i]] = struct{}{}
	}
}

// RemovedPaths returns the removed IDs of the "paths" edge to the Path entity.
func (m *ExampleMutation) RemovedPathsIDs() (ids []int) {
	for id := range m.removedpaths {
		ids = append(ids, id)
	}
	return
}

// PathsIDs returns the "paths" edge IDs in the mutation.
func (m *ExampleMutation) PathsIDs() (ids []int) {
	for id := range m.paths {
		ids = append(ids, id)
	}
	return
}

// ResetPaths resets all changes to the "paths" edge.
func (m *ExampleMutation) ResetPaths() {
	m.paths = nil
	m.clearedpaths = false
	m.removedpaths = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *ExampleMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *ExampleMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *ExampleMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *ExampleMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *ExampleMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *ExampleMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *ExampleMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *ExampleMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *ExampleMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *ExampleMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *ExampleMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *ExampleMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *ExampleMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *ExampleMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *ExampleMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *ExampleMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *ExampleMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *ExampleMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *ExampleMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *ExampleMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *ExampleMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the ExampleMutation builder.
func (m *ExampleMutation) Where(ps ...predicate.Example) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExampleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExampleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Example, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExampleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExampleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Example).
func (m *ExampleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExampleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.timestamp != nil {
		fields = append(fields, example.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExampleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case example.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExampleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case example.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Example field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExampleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case example.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Example field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExampleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExampleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExampleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Example numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExampleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExampleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExampleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Example nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExampleMutation) ResetField(name string) error {
	switch name {
	case example.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Example field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExampleMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.ipaddress != nil {
		edges = append(edges, example.EdgeIpaddress)
	}
	if m.next != nil {
		edges = append(edges, example.EdgeNext)
	}
	if m.dnsentry != nil {
		edges = append(edges, example.EdgeDnsentry)
	}
	if m.domain != nil {
		edges = append(edges, example.EdgeDomain)
	}
	if m.paths != nil {
		edges = append(edges, example.EdgePaths)
	}
	if m.nameserver != nil {
		edges = append(edges, example.EdgeNameserver)
	}
	if m.registrar != nil {
		edges = append(edges, example.EdgeRegistrar)
	}
	if m.whois != nil {
		edges = append(edges, example.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExampleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case example.EdgeIpaddress:
		if id := m.ipaddress; id != nil {
			return []ent.Value{*id}
		}
	case example.EdgeNext:
		ids := make([]ent.Value, 0, len(m.next))
		for id := range m.next {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.dnsentry))
		for id := range m.dnsentry {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case example.EdgePaths:
		ids := make([]ent.Value, 0, len(m.paths))
		for id := range m.paths {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExampleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removednext != nil {
		edges = append(edges, example.EdgeNext)
	}
	if m.removeddnsentry != nil {
		edges = append(edges, example.EdgeDnsentry)
	}
	if m.removeddomain != nil {
		edges = append(edges, example.EdgeDomain)
	}
	if m.removedpaths != nil {
		edges = append(edges, example.EdgePaths)
	}
	if m.removednameserver != nil {
		edges = append(edges, example.EdgeNameserver)
	}
	if m.removedregistrar != nil {
		edges = append(edges, example.EdgeRegistrar)
	}
	if m.removedwhois != nil {
		edges = append(edges, example.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExampleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case example.EdgeNext:
		ids := make([]ent.Value, 0, len(m.removednext))
		for id := range m.removednext {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.removeddnsentry))
		for id := range m.removeddnsentry {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case example.EdgePaths:
		ids := make([]ent.Value, 0, len(m.removedpaths))
		for id := range m.removedpaths {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case example.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExampleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedipaddress {
		edges = append(edges, example.EdgeIpaddress)
	}
	if m.clearednext {
		edges = append(edges, example.EdgeNext)
	}
	if m.cleareddnsentry {
		edges = append(edges, example.EdgeDnsentry)
	}
	if m.cleareddomain {
		edges = append(edges, example.EdgeDomain)
	}
	if m.clearedpaths {
		edges = append(edges, example.EdgePaths)
	}
	if m.clearednameserver {
		edges = append(edges, example.EdgeNameserver)
	}
	if m.clearedregistrar {
		edges = append(edges, example.EdgeRegistrar)
	}
	if m.clearedwhois {
		edges = append(edges, example.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExampleMutation) EdgeCleared(name string) bool {
	switch name {
	case example.EdgeIpaddress:
		return m.clearedipaddress
	case example.EdgeNext:
		return m.clearednext
	case example.EdgeDnsentry:
		return m.cleareddnsentry
	case example.EdgeDomain:
		return m.cleareddomain
	case example.EdgePaths:
		return m.clearedpaths
	case example.EdgeNameserver:
		return m.clearednameserver
	case example.EdgeRegistrar:
		return m.clearedregistrar
	case example.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExampleMutation) ClearEdge(name string) error {
	switch name {
	case example.EdgeIpaddress:
		m.ClearIpaddress()
		return nil
	}
	return fmt.Errorf("unknown Example unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExampleMutation) ResetEdge(name string) error {
	switch name {
	case example.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case example.EdgeNext:
		m.ResetNext()
		return nil
	case example.EdgeDnsentry:
		m.ResetDnsentry()
		return nil
	case example.EdgeDomain:
		m.ResetDomain()
		return nil
	case example.EdgePaths:
		m.ResetPaths()
		return nil
	case example.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case example.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case example.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown Example edge %s", name)
}

// IPAddressMutation represents an operation that mutates the IPAddress nodes in the graph.
type IPAddressMutation struct {
	config
	op                Op
	typ               string
	id                *int
	ip                *string
	mask              *string
	clearedFields     map[string]struct{}
	asninfo           map[int]struct{}
	removedasninfo    map[int]struct{}
	clearedasninfo    bool
	scan              map[int]struct{}
	removedscan       map[int]struct{}
	clearedscan       bool
	dnsentry          map[int]struct{}
	removeddnsentry   map[int]struct{}
	cleareddnsentry   bool
	domain            map[int]struct{}
	removeddomain     map[int]struct{}
	cleareddomain     bool
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	registrar         map[int]struct{}
	removedregistrar  map[int]struct{}
	clearedregistrar  bool
	whois             map[int]struct{}
	removedwhois      map[int]struct{}
	clearedwhois      bool
	done              bool
	oldValue          func(context.Context) (*IPAddress, error)
	predicates        []predicate.IPAddress
}

var _ ent.Mutation = (*IPAddressMutation)(nil)

// ipaddressOption allows management of the mutation configuration using functional options.
type ipaddressOption func(*IPAddressMutation)

// newIPAddressMutation creates new mutation for the IPAddress entity.
func newIPAddressMutation(c config, op Op, opts ...ipaddressOption) *IPAddressMutation {
	m := &IPAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeIPAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPAddressID sets the ID field of the mutation.
func withIPAddressID(id int) ipaddressOption {
	return func(m *IPAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *IPAddress
		)
		m.oldValue = func(ctx context.Context) (*IPAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPAddress sets the old IPAddress of the mutation.
func withIPAddress(node *IPAddress) ipaddressOption {
	return func(m *IPAddressMutation) {
		m.oldValue = func(context.Context) (*IPAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPAddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPAddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIP sets the "ip" field.
func (m *IPAddressMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *IPAddressMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the IPAddress entity.
// If the IPAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPAddressMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *IPAddressMutation) ResetIP() {
	m.ip = nil
}

// SetMask sets the "mask" field.
func (m *IPAddressMutation) SetMask(s string) {
	m.mask = &s
}

// Mask returns the value of the "mask" field in the mutation.
func (m *IPAddressMutation) Mask() (r string, exists bool) {
	v := m.mask
	if v == nil {
		return
	}
	return *v, true
}

// OldMask returns the old "mask" field's value of the IPAddress entity.
// If the IPAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPAddressMutation) OldMask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMask: %w", err)
	}
	return oldValue.Mask, nil
}

// ResetMask resets all changes to the "mask" field.
func (m *IPAddressMutation) ResetMask() {
	m.mask = nil
}

// AddAsninfoIDs adds the "asninfo" edge to the ASNInfo entity by ids.
func (m *IPAddressMutation) AddAsninfoIDs(ids ...int) {
	if m.asninfo == nil {
		m.asninfo = make(map[int]struct{})
	}
	for i := range ids {
		m.asninfo[ids[i]] = struct{}{}
	}
}

// ClearAsninfo clears the "asninfo" edge to the ASNInfo entity.
func (m *IPAddressMutation) ClearAsninfo() {
	m.clearedasninfo = true
}

// AsninfoCleared reports if the "asninfo" edge to the ASNInfo entity was cleared.
func (m *IPAddressMutation) AsninfoCleared() bool {
	return m.clearedasninfo
}

// RemoveAsninfoIDs removes the "asninfo" edge to the ASNInfo entity by IDs.
func (m *IPAddressMutation) RemoveAsninfoIDs(ids ...int) {
	if m.removedasninfo == nil {
		m.removedasninfo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asninfo, ids[i])
		m.removedasninfo[ids[i]] = struct{}{}
	}
}

// RemovedAsninfo returns the removed IDs of the "asninfo" edge to the ASNInfo entity.
func (m *IPAddressMutation) RemovedAsninfoIDs() (ids []int) {
	for id := range m.removedasninfo {
		ids = append(ids, id)
	}
	return
}

// AsninfoIDs returns the "asninfo" edge IDs in the mutation.
func (m *IPAddressMutation) AsninfoIDs() (ids []int) {
	for id := range m.asninfo {
		ids = append(ids, id)
	}
	return
}

// ResetAsninfo resets all changes to the "asninfo" edge.
func (m *IPAddressMutation) ResetAsninfo() {
	m.asninfo = nil
	m.clearedasninfo = false
	m.removedasninfo = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *IPAddressMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *IPAddressMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *IPAddressMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *IPAddressMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *IPAddressMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *IPAddressMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *IPAddressMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddDnsentryIDs adds the "dnsentry" edge to the DNSEntry entity by ids.
func (m *IPAddressMutation) AddDnsentryIDs(ids ...int) {
	if m.dnsentry == nil {
		m.dnsentry = make(map[int]struct{})
	}
	for i := range ids {
		m.dnsentry[ids[i]] = struct{}{}
	}
}

// ClearDnsentry clears the "dnsentry" edge to the DNSEntry entity.
func (m *IPAddressMutation) ClearDnsentry() {
	m.cleareddnsentry = true
}

// DnsentryCleared reports if the "dnsentry" edge to the DNSEntry entity was cleared.
func (m *IPAddressMutation) DnsentryCleared() bool {
	return m.cleareddnsentry
}

// RemoveDnsentryIDs removes the "dnsentry" edge to the DNSEntry entity by IDs.
func (m *IPAddressMutation) RemoveDnsentryIDs(ids ...int) {
	if m.removeddnsentry == nil {
		m.removeddnsentry = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dnsentry, ids[i])
		m.removeddnsentry[ids[i]] = struct{}{}
	}
}

// RemovedDnsentry returns the removed IDs of the "dnsentry" edge to the DNSEntry entity.
func (m *IPAddressMutation) RemovedDnsentryIDs() (ids []int) {
	for id := range m.removeddnsentry {
		ids = append(ids, id)
	}
	return
}

// DnsentryIDs returns the "dnsentry" edge IDs in the mutation.
func (m *IPAddressMutation) DnsentryIDs() (ids []int) {
	for id := range m.dnsentry {
		ids = append(ids, id)
	}
	return
}

// ResetDnsentry resets all changes to the "dnsentry" edge.
func (m *IPAddressMutation) ResetDnsentry() {
	m.dnsentry = nil
	m.cleareddnsentry = false
	m.removeddnsentry = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *IPAddressMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *IPAddressMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *IPAddressMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *IPAddressMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *IPAddressMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *IPAddressMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *IPAddressMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *IPAddressMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *IPAddressMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *IPAddressMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *IPAddressMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *IPAddressMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *IPAddressMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *IPAddressMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *IPAddressMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *IPAddressMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *IPAddressMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *IPAddressMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *IPAddressMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *IPAddressMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *IPAddressMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *IPAddressMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *IPAddressMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *IPAddressMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *IPAddressMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *IPAddressMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *IPAddressMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *IPAddressMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the IPAddressMutation builder.
func (m *IPAddressMutation) Where(ps ...predicate.IPAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPAddress).
func (m *IPAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPAddressMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.ip != nil {
		fields = append(fields, ipaddress.FieldIP)
	}
	if m.mask != nil {
		fields = append(fields, ipaddress.FieldMask)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipaddress.FieldIP:
		return m.IP()
	case ipaddress.FieldMask:
		return m.Mask()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipaddress.FieldIP:
		return m.OldIP(ctx)
	case ipaddress.FieldMask:
		return m.OldMask(ctx)
	}
	return nil, fmt.Errorf("unknown IPAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipaddress.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case ipaddress.FieldMask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMask(v)
		return nil
	}
	return fmt.Errorf("unknown IPAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IPAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IPAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPAddressMutation) ResetField(name string) error {
	switch name {
	case ipaddress.FieldIP:
		m.ResetIP()
		return nil
	case ipaddress.FieldMask:
		m.ResetMask()
		return nil
	}
	return fmt.Errorf("unknown IPAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.asninfo != nil {
		edges = append(edges, ipaddress.EdgeAsninfo)
	}
	if m.scan != nil {
		edges = append(edges, ipaddress.EdgeScan)
	}
	if m.dnsentry != nil {
		edges = append(edges, ipaddress.EdgeDnsentry)
	}
	if m.domain != nil {
		edges = append(edges, ipaddress.EdgeDomain)
	}
	if m.nameserver != nil {
		edges = append(edges, ipaddress.EdgeNameserver)
	}
	if m.registrar != nil {
		edges = append(edges, ipaddress.EdgeRegistrar)
	}
	if m.whois != nil {
		edges = append(edges, ipaddress.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipaddress.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.asninfo))
		for id := range m.asninfo {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.dnsentry))
		for id := range m.dnsentry {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedasninfo != nil {
		edges = append(edges, ipaddress.EdgeAsninfo)
	}
	if m.removedscan != nil {
		edges = append(edges, ipaddress.EdgeScan)
	}
	if m.removeddnsentry != nil {
		edges = append(edges, ipaddress.EdgeDnsentry)
	}
	if m.removeddomain != nil {
		edges = append(edges, ipaddress.EdgeDomain)
	}
	if m.removednameserver != nil {
		edges = append(edges, ipaddress.EdgeNameserver)
	}
	if m.removedregistrar != nil {
		edges = append(edges, ipaddress.EdgeRegistrar)
	}
	if m.removedwhois != nil {
		edges = append(edges, ipaddress.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ipaddress.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.removedasninfo))
		for id := range m.removedasninfo {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.removeddnsentry))
		for id := range m.removeddnsentry {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case ipaddress.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedasninfo {
		edges = append(edges, ipaddress.EdgeAsninfo)
	}
	if m.clearedscan {
		edges = append(edges, ipaddress.EdgeScan)
	}
	if m.cleareddnsentry {
		edges = append(edges, ipaddress.EdgeDnsentry)
	}
	if m.cleareddomain {
		edges = append(edges, ipaddress.EdgeDomain)
	}
	if m.clearednameserver {
		edges = append(edges, ipaddress.EdgeNameserver)
	}
	if m.clearedregistrar {
		edges = append(edges, ipaddress.EdgeRegistrar)
	}
	if m.clearedwhois {
		edges = append(edges, ipaddress.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case ipaddress.EdgeAsninfo:
		return m.clearedasninfo
	case ipaddress.EdgeScan:
		return m.clearedscan
	case ipaddress.EdgeDnsentry:
		return m.cleareddnsentry
	case ipaddress.EdgeDomain:
		return m.cleareddomain
	case ipaddress.EdgeNameserver:
		return m.clearednameserver
	case ipaddress.EdgeRegistrar:
		return m.clearedregistrar
	case ipaddress.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPAddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown IPAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPAddressMutation) ResetEdge(name string) error {
	switch name {
	case ipaddress.EdgeAsninfo:
		m.ResetAsninfo()
		return nil
	case ipaddress.EdgeScan:
		m.ResetScan()
		return nil
	case ipaddress.EdgeDnsentry:
		m.ResetDnsentry()
		return nil
	case ipaddress.EdgeDomain:
		m.ResetDomain()
		return nil
	case ipaddress.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case ipaddress.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case ipaddress.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown IPAddress edge %s", name)
}

// NameserverMutation represents an operation that mutates the Nameserver nodes in the graph.
type NameserverMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	time_first       *time.Time
	time_last        *time.Time
	clearedFields    map[string]struct{}
	ipaddress        map[int]struct{}
	removedipaddress map[int]struct{}
	clearedipaddress bool
	scan             map[int]struct{}
	removedscan      map[int]struct{}
	clearedscan      bool
	dnsentry         map[int]struct{}
	removeddnsentry  map[int]struct{}
	cleareddnsentry  bool
	domain           map[int]struct{}
	removeddomain    map[int]struct{}
	cleareddomain    bool
	whois            map[int]struct{}
	removedwhois     map[int]struct{}
	clearedwhois     bool
	done             bool
	oldValue         func(context.Context) (*Nameserver, error)
	predicates       []predicate.Nameserver
}

var _ ent.Mutation = (*NameserverMutation)(nil)

// nameserverOption allows management of the mutation configuration using functional options.
type nameserverOption func(*NameserverMutation)

// newNameserverMutation creates new mutation for the Nameserver entity.
func newNameserverMutation(c config, op Op, opts ...nameserverOption) *NameserverMutation {
	m := &NameserverMutation{
		config:        c,
		op:            op,
		typ:           TypeNameserver,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNameserverID sets the ID field of the mutation.
func withNameserverID(id int) nameserverOption {
	return func(m *NameserverMutation) {
		var (
			err   error
			once  sync.Once
			value *Nameserver
		)
		m.oldValue = func(ctx context.Context) (*Nameserver, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nameserver.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNameserver sets the old Nameserver of the mutation.
func withNameserver(node *Nameserver) nameserverOption {
	return func(m *NameserverMutation) {
		m.oldValue = func(context.Context) (*Nameserver, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NameserverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NameserverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NameserverMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NameserverMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nameserver.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NameserverMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NameserverMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Nameserver entity.
// If the Nameserver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NameserverMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NameserverMutation) ResetName() {
	m.name = nil
}

// SetTimeFirst sets the "time_first" field.
func (m *NameserverMutation) SetTimeFirst(t time.Time) {
	m.time_first = &t
}

// TimeFirst returns the value of the "time_first" field in the mutation.
func (m *NameserverMutation) TimeFirst() (r time.Time, exists bool) {
	v := m.time_first
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFirst returns the old "time_first" field's value of the Nameserver entity.
// If the Nameserver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NameserverMutation) OldTimeFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFirst: %w", err)
	}
	return oldValue.TimeFirst, nil
}

// ResetTimeFirst resets all changes to the "time_first" field.
func (m *NameserverMutation) ResetTimeFirst() {
	m.time_first = nil
}

// SetTimeLast sets the "time_last" field.
func (m *NameserverMutation) SetTimeLast(t time.Time) {
	m.time_last = &t
}

// TimeLast returns the value of the "time_last" field in the mutation.
func (m *NameserverMutation) TimeLast() (r time.Time, exists bool) {
	v := m.time_last
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLast returns the old "time_last" field's value of the Nameserver entity.
// If the Nameserver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NameserverMutation) OldTimeLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLast: %w", err)
	}
	return oldValue.TimeLast, nil
}

// ResetTimeLast resets all changes to the "time_last" field.
func (m *NameserverMutation) ResetTimeLast() {
	m.time_last = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *NameserverMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *NameserverMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *NameserverMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *NameserverMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *NameserverMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *NameserverMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *NameserverMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *NameserverMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *NameserverMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *NameserverMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *NameserverMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *NameserverMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *NameserverMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *NameserverMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddDnsentryIDs adds the "dnsentry" edge to the DNSEntry entity by ids.
func (m *NameserverMutation) AddDnsentryIDs(ids ...int) {
	if m.dnsentry == nil {
		m.dnsentry = make(map[int]struct{})
	}
	for i := range ids {
		m.dnsentry[ids[i]] = struct{}{}
	}
}

// ClearDnsentry clears the "dnsentry" edge to the DNSEntry entity.
func (m *NameserverMutation) ClearDnsentry() {
	m.cleareddnsentry = true
}

// DnsentryCleared reports if the "dnsentry" edge to the DNSEntry entity was cleared.
func (m *NameserverMutation) DnsentryCleared() bool {
	return m.cleareddnsentry
}

// RemoveDnsentryIDs removes the "dnsentry" edge to the DNSEntry entity by IDs.
func (m *NameserverMutation) RemoveDnsentryIDs(ids ...int) {
	if m.removeddnsentry == nil {
		m.removeddnsentry = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dnsentry, ids[i])
		m.removeddnsentry[ids[i]] = struct{}{}
	}
}

// RemovedDnsentry returns the removed IDs of the "dnsentry" edge to the DNSEntry entity.
func (m *NameserverMutation) RemovedDnsentryIDs() (ids []int) {
	for id := range m.removeddnsentry {
		ids = append(ids, id)
	}
	return
}

// DnsentryIDs returns the "dnsentry" edge IDs in the mutation.
func (m *NameserverMutation) DnsentryIDs() (ids []int) {
	for id := range m.dnsentry {
		ids = append(ids, id)
	}
	return
}

// ResetDnsentry resets all changes to the "dnsentry" edge.
func (m *NameserverMutation) ResetDnsentry() {
	m.dnsentry = nil
	m.cleareddnsentry = false
	m.removeddnsentry = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *NameserverMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *NameserverMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *NameserverMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *NameserverMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *NameserverMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *NameserverMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *NameserverMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *NameserverMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *NameserverMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *NameserverMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *NameserverMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *NameserverMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *NameserverMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *NameserverMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the NameserverMutation builder.
func (m *NameserverMutation) Where(ps ...predicate.Nameserver) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NameserverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NameserverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Nameserver, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NameserverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NameserverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Nameserver).
func (m *NameserverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NameserverMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, nameserver.FieldName)
	}
	if m.time_first != nil {
		fields = append(fields, nameserver.FieldTimeFirst)
	}
	if m.time_last != nil {
		fields = append(fields, nameserver.FieldTimeLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NameserverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nameserver.FieldName:
		return m.Name()
	case nameserver.FieldTimeFirst:
		return m.TimeFirst()
	case nameserver.FieldTimeLast:
		return m.TimeLast()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NameserverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nameserver.FieldName:
		return m.OldName(ctx)
	case nameserver.FieldTimeFirst:
		return m.OldTimeFirst(ctx)
	case nameserver.FieldTimeLast:
		return m.OldTimeLast(ctx)
	}
	return nil, fmt.Errorf("unknown Nameserver field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NameserverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nameserver.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nameserver.FieldTimeFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFirst(v)
		return nil
	case nameserver.FieldTimeLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLast(v)
		return nil
	}
	return fmt.Errorf("unknown Nameserver field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NameserverMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NameserverMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NameserverMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nameserver numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NameserverMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NameserverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NameserverMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nameserver nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NameserverMutation) ResetField(name string) error {
	switch name {
	case nameserver.FieldName:
		m.ResetName()
		return nil
	case nameserver.FieldTimeFirst:
		m.ResetTimeFirst()
		return nil
	case nameserver.FieldTimeLast:
		m.ResetTimeLast()
		return nil
	}
	return fmt.Errorf("unknown Nameserver field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NameserverMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.ipaddress != nil {
		edges = append(edges, nameserver.EdgeIpaddress)
	}
	if m.scan != nil {
		edges = append(edges, nameserver.EdgeScan)
	}
	if m.dnsentry != nil {
		edges = append(edges, nameserver.EdgeDnsentry)
	}
	if m.domain != nil {
		edges = append(edges, nameserver.EdgeDomain)
	}
	if m.whois != nil {
		edges = append(edges, nameserver.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NameserverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nameserver.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.dnsentry))
		for id := range m.dnsentry {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NameserverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedipaddress != nil {
		edges = append(edges, nameserver.EdgeIpaddress)
	}
	if m.removedscan != nil {
		edges = append(edges, nameserver.EdgeScan)
	}
	if m.removeddnsentry != nil {
		edges = append(edges, nameserver.EdgeDnsentry)
	}
	if m.removeddomain != nil {
		edges = append(edges, nameserver.EdgeDomain)
	}
	if m.removedwhois != nil {
		edges = append(edges, nameserver.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NameserverMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nameserver.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.removeddnsentry))
		for id := range m.removeddnsentry {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case nameserver.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NameserverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedipaddress {
		edges = append(edges, nameserver.EdgeIpaddress)
	}
	if m.clearedscan {
		edges = append(edges, nameserver.EdgeScan)
	}
	if m.cleareddnsentry {
		edges = append(edges, nameserver.EdgeDnsentry)
	}
	if m.cleareddomain {
		edges = append(edges, nameserver.EdgeDomain)
	}
	if m.clearedwhois {
		edges = append(edges, nameserver.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NameserverMutation) EdgeCleared(name string) bool {
	switch name {
	case nameserver.EdgeIpaddress:
		return m.clearedipaddress
	case nameserver.EdgeScan:
		return m.clearedscan
	case nameserver.EdgeDnsentry:
		return m.cleareddnsentry
	case nameserver.EdgeDomain:
		return m.cleareddomain
	case nameserver.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NameserverMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nameserver unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NameserverMutation) ResetEdge(name string) error {
	switch name {
	case nameserver.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case nameserver.EdgeScan:
		m.ResetScan()
		return nil
	case nameserver.EdgeDnsentry:
		m.ResetDnsentry()
		return nil
	case nameserver.EdgeDomain:
		m.ResetDomain()
		return nil
	case nameserver.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown Nameserver edge %s", name)
}

// PathMutation represents an operation that mutates the Path nodes in the graph.
type PathMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	clearedFields map[string]struct{}
	domain        map[int]struct{}
	removeddomain map[int]struct{}
	cleareddomain bool
	scan          map[int]struct{}
	removedscan   map[int]struct{}
	clearedscan   bool
	done          bool
	oldValue      func(context.Context) (*Path, error)
	predicates    []predicate.Path
}

var _ ent.Mutation = (*PathMutation)(nil)

// pathOption allows management of the mutation configuration using functional options.
type pathOption func(*PathMutation)

// newPathMutation creates new mutation for the Path entity.
func newPathMutation(c config, op Op, opts ...pathOption) *PathMutation {
	m := &PathMutation{
		config:        c,
		op:            op,
		typ:           TypePath,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPathID sets the ID field of the mutation.
func withPathID(id int) pathOption {
	return func(m *PathMutation) {
		var (
			err   error
			once  sync.Once
			value *Path
		)
		m.oldValue = func(ctx context.Context) (*Path, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Path.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPath sets the old Path of the mutation.
func withPath(node *Path) pathOption {
	return func(m *PathMutation) {
		m.oldValue = func(context.Context) (*Path, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PathMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PathMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PathMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PathMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Path.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *PathMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *PathMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Path entity.
// If the Path object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PathMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *PathMutation) ResetPath() {
	m._path = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *PathMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *PathMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *PathMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *PathMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *PathMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *PathMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *PathMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *PathMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *PathMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *PathMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *PathMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *PathMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *PathMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *PathMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// Where appends a list predicates to the PathMutation builder.
func (m *PathMutation) Where(ps ...predicate.Path) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PathMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PathMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Path, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PathMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PathMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Path).
func (m *PathMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PathMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._path != nil {
		fields = append(fields, path.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PathMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case path.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PathMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case path.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Path field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PathMutation) SetField(name string, value ent.Value) error {
	switch name {
	case path.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Path field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PathMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PathMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PathMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Path numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PathMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PathMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PathMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Path nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PathMutation) ResetField(name string) error {
	switch name {
	case path.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Path field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PathMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.domain != nil {
		edges = append(edges, path.EdgeDomain)
	}
	if m.scan != nil {
		edges = append(edges, path.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PathMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case path.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case path.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PathMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddomain != nil {
		edges = append(edges, path.EdgeDomain)
	}
	if m.removedscan != nil {
		edges = append(edges, path.EdgeScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PathMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case path.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case path.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PathMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddomain {
		edges = append(edges, path.EdgeDomain)
	}
	if m.clearedscan {
		edges = append(edges, path.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PathMutation) EdgeCleared(name string) bool {
	switch name {
	case path.EdgeDomain:
		return m.cleareddomain
	case path.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PathMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Path unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PathMutation) ResetEdge(name string) error {
	switch name {
	case path.EdgeDomain:
		m.ResetDomain()
		return nil
	case path.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown Path edge %s", name)
}

// RegistrarMutation represents an operation that mutates the Registrar nodes in the graph.
type RegistrarMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	url              *string
	country_code     *string
	phone            *string
	fax              *string
	address          *string
	source           *string
	time_first       *time.Time
	time_last        *time.Time
	clearedFields    map[string]struct{}
	ipaddress        map[int]struct{}
	removedipaddress map[int]struct{}
	clearedipaddress bool
	domain           map[int]struct{}
	removeddomain    map[int]struct{}
	cleareddomain    bool
	asninfo          map[int]struct{}
	removedasninfo   map[int]struct{}
	clearedasninfo   bool
	scan             map[int]struct{}
	removedscan      map[int]struct{}
	clearedscan      bool
	whois            map[int]struct{}
	removedwhois     map[int]struct{}
	clearedwhois     bool
	done             bool
	oldValue         func(context.Context) (*Registrar, error)
	predicates       []predicate.Registrar
}

var _ ent.Mutation = (*RegistrarMutation)(nil)

// registrarOption allows management of the mutation configuration using functional options.
type registrarOption func(*RegistrarMutation)

// newRegistrarMutation creates new mutation for the Registrar entity.
func newRegistrarMutation(c config, op Op, opts ...registrarOption) *RegistrarMutation {
	m := &RegistrarMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistrar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistrarID sets the ID field of the mutation.
func withRegistrarID(id int) registrarOption {
	return func(m *RegistrarMutation) {
		var (
			err   error
			once  sync.Once
			value *Registrar
		)
		m.oldValue = func(ctx context.Context) (*Registrar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registrar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistrar sets the old Registrar of the mutation.
func withRegistrar(node *Registrar) registrarOption {
	return func(m *RegistrarMutation) {
		m.oldValue = func(context.Context) (*Registrar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistrarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistrarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegistrarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegistrarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Registrar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RegistrarMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegistrarMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegistrarMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *RegistrarMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *RegistrarMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *RegistrarMutation) ResetURL() {
	m.url = nil
}

// SetCountryCode sets the "country_code" field.
func (m *RegistrarMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *RegistrarMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *RegistrarMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetPhone sets the "phone" field.
func (m *RegistrarMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RegistrarMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RegistrarMutation) ResetPhone() {
	m.phone = nil
}

// SetFax sets the "fax" field.
func (m *RegistrarMutation) SetFax(s string) {
	m.fax = &s
}

// Fax returns the value of the "fax" field in the mutation.
func (m *RegistrarMutation) Fax() (r string, exists bool) {
	v := m.fax
	if v == nil {
		return
	}
	return *v, true
}

// OldFax returns the old "fax" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldFax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFax: %w", err)
	}
	return oldValue.Fax, nil
}

// ResetFax resets all changes to the "fax" field.
func (m *RegistrarMutation) ResetFax() {
	m.fax = nil
}

// SetAddress sets the "address" field.
func (m *RegistrarMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *RegistrarMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *RegistrarMutation) ResetAddress() {
	m.address = nil
}

// SetSource sets the "source" field.
func (m *RegistrarMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *RegistrarMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RegistrarMutation) ResetSource() {
	m.source = nil
}

// SetTimeFirst sets the "time_first" field.
func (m *RegistrarMutation) SetTimeFirst(t time.Time) {
	m.time_first = &t
}

// TimeFirst returns the value of the "time_first" field in the mutation.
func (m *RegistrarMutation) TimeFirst() (r time.Time, exists bool) {
	v := m.time_first
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFirst returns the old "time_first" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldTimeFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFirst: %w", err)
	}
	return oldValue.TimeFirst, nil
}

// ResetTimeFirst resets all changes to the "time_first" field.
func (m *RegistrarMutation) ResetTimeFirst() {
	m.time_first = nil
}

// SetTimeLast sets the "time_last" field.
func (m *RegistrarMutation) SetTimeLast(t time.Time) {
	m.time_last = &t
}

// TimeLast returns the value of the "time_last" field in the mutation.
func (m *RegistrarMutation) TimeLast() (r time.Time, exists bool) {
	v := m.time_last
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLast returns the old "time_last" field's value of the Registrar entity.
// If the Registrar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrarMutation) OldTimeLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLast: %w", err)
	}
	return oldValue.TimeLast, nil
}

// ResetTimeLast resets all changes to the "time_last" field.
func (m *RegistrarMutation) ResetTimeLast() {
	m.time_last = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *RegistrarMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *RegistrarMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *RegistrarMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *RegistrarMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *RegistrarMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *RegistrarMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *RegistrarMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *RegistrarMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *RegistrarMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *RegistrarMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *RegistrarMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *RegistrarMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *RegistrarMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *RegistrarMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddAsninfoIDs adds the "asninfo" edge to the ASNInfo entity by ids.
func (m *RegistrarMutation) AddAsninfoIDs(ids ...int) {
	if m.asninfo == nil {
		m.asninfo = make(map[int]struct{})
	}
	for i := range ids {
		m.asninfo[ids[i]] = struct{}{}
	}
}

// ClearAsninfo clears the "asninfo" edge to the ASNInfo entity.
func (m *RegistrarMutation) ClearAsninfo() {
	m.clearedasninfo = true
}

// AsninfoCleared reports if the "asninfo" edge to the ASNInfo entity was cleared.
func (m *RegistrarMutation) AsninfoCleared() bool {
	return m.clearedasninfo
}

// RemoveAsninfoIDs removes the "asninfo" edge to the ASNInfo entity by IDs.
func (m *RegistrarMutation) RemoveAsninfoIDs(ids ...int) {
	if m.removedasninfo == nil {
		m.removedasninfo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asninfo, ids[i])
		m.removedasninfo[ids[i]] = struct{}{}
	}
}

// RemovedAsninfo returns the removed IDs of the "asninfo" edge to the ASNInfo entity.
func (m *RegistrarMutation) RemovedAsninfoIDs() (ids []int) {
	for id := range m.removedasninfo {
		ids = append(ids, id)
	}
	return
}

// AsninfoIDs returns the "asninfo" edge IDs in the mutation.
func (m *RegistrarMutation) AsninfoIDs() (ids []int) {
	for id := range m.asninfo {
		ids = append(ids, id)
	}
	return
}

// ResetAsninfo resets all changes to the "asninfo" edge.
func (m *RegistrarMutation) ResetAsninfo() {
	m.asninfo = nil
	m.clearedasninfo = false
	m.removedasninfo = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *RegistrarMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *RegistrarMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *RegistrarMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *RegistrarMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *RegistrarMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *RegistrarMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *RegistrarMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *RegistrarMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *RegistrarMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *RegistrarMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *RegistrarMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *RegistrarMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *RegistrarMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *RegistrarMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// Where appends a list predicates to the RegistrarMutation builder.
func (m *RegistrarMutation) Where(ps ...predicate.Registrar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegistrarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegistrarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Registrar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegistrarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegistrarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Registrar).
func (m *RegistrarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegistrarMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, registrar.FieldName)
	}
	if m.url != nil {
		fields = append(fields, registrar.FieldURL)
	}
	if m.country_code != nil {
		fields = append(fields, registrar.FieldCountryCode)
	}
	if m.phone != nil {
		fields = append(fields, registrar.FieldPhone)
	}
	if m.fax != nil {
		fields = append(fields, registrar.FieldFax)
	}
	if m.address != nil {
		fields = append(fields, registrar.FieldAddress)
	}
	if m.source != nil {
		fields = append(fields, registrar.FieldSource)
	}
	if m.time_first != nil {
		fields = append(fields, registrar.FieldTimeFirst)
	}
	if m.time_last != nil {
		fields = append(fields, registrar.FieldTimeLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegistrarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registrar.FieldName:
		return m.Name()
	case registrar.FieldURL:
		return m.URL()
	case registrar.FieldCountryCode:
		return m.CountryCode()
	case registrar.FieldPhone:
		return m.Phone()
	case registrar.FieldFax:
		return m.Fax()
	case registrar.FieldAddress:
		return m.Address()
	case registrar.FieldSource:
		return m.Source()
	case registrar.FieldTimeFirst:
		return m.TimeFirst()
	case registrar.FieldTimeLast:
		return m.TimeLast()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegistrarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registrar.FieldName:
		return m.OldName(ctx)
	case registrar.FieldURL:
		return m.OldURL(ctx)
	case registrar.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case registrar.FieldPhone:
		return m.OldPhone(ctx)
	case registrar.FieldFax:
		return m.OldFax(ctx)
	case registrar.FieldAddress:
		return m.OldAddress(ctx)
	case registrar.FieldSource:
		return m.OldSource(ctx)
	case registrar.FieldTimeFirst:
		return m.OldTimeFirst(ctx)
	case registrar.FieldTimeLast:
		return m.OldTimeLast(ctx)
	}
	return nil, fmt.Errorf("unknown Registrar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registrar.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case registrar.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case registrar.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case registrar.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case registrar.FieldFax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFax(v)
		return nil
	case registrar.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case registrar.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case registrar.FieldTimeFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFirst(v)
		return nil
	case registrar.FieldTimeLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLast(v)
		return nil
	}
	return fmt.Errorf("unknown Registrar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegistrarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegistrarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Registrar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegistrarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegistrarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistrarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Registrar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegistrarMutation) ResetField(name string) error {
	switch name {
	case registrar.FieldName:
		m.ResetName()
		return nil
	case registrar.FieldURL:
		m.ResetURL()
		return nil
	case registrar.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case registrar.FieldPhone:
		m.ResetPhone()
		return nil
	case registrar.FieldFax:
		m.ResetFax()
		return nil
	case registrar.FieldAddress:
		m.ResetAddress()
		return nil
	case registrar.FieldSource:
		m.ResetSource()
		return nil
	case registrar.FieldTimeFirst:
		m.ResetTimeFirst()
		return nil
	case registrar.FieldTimeLast:
		m.ResetTimeLast()
		return nil
	}
	return fmt.Errorf("unknown Registrar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegistrarMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.ipaddress != nil {
		edges = append(edges, registrar.EdgeIpaddress)
	}
	if m.domain != nil {
		edges = append(edges, registrar.EdgeDomain)
	}
	if m.asninfo != nil {
		edges = append(edges, registrar.EdgeAsninfo)
	}
	if m.scan != nil {
		edges = append(edges, registrar.EdgeScan)
	}
	if m.whois != nil {
		edges = append(edges, registrar.EdgeWhois)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegistrarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case registrar.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.asninfo))
		for id := range m.asninfo {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegistrarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedipaddress != nil {
		edges = append(edges, registrar.EdgeIpaddress)
	}
	if m.removeddomain != nil {
		edges = append(edges, registrar.EdgeDomain)
	}
	if m.removedasninfo != nil {
		edges = append(edges, registrar.EdgeAsninfo)
	}
	if m.removedscan != nil {
		edges = append(edges, registrar.EdgeScan)
	}
	if m.removedwhois != nil {
		edges = append(edges, registrar.EdgeWhois)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegistrarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case registrar.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.removedasninfo))
		for id := range m.removedasninfo {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	case registrar.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegistrarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedipaddress {
		edges = append(edges, registrar.EdgeIpaddress)
	}
	if m.cleareddomain {
		edges = append(edges, registrar.EdgeDomain)
	}
	if m.clearedasninfo {
		edges = append(edges, registrar.EdgeAsninfo)
	}
	if m.clearedscan {
		edges = append(edges, registrar.EdgeScan)
	}
	if m.clearedwhois {
		edges = append(edges, registrar.EdgeWhois)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegistrarMutation) EdgeCleared(name string) bool {
	switch name {
	case registrar.EdgeIpaddress:
		return m.clearedipaddress
	case registrar.EdgeDomain:
		return m.cleareddomain
	case registrar.EdgeAsninfo:
		return m.clearedasninfo
	case registrar.EdgeScan:
		return m.clearedscan
	case registrar.EdgeWhois:
		return m.clearedwhois
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegistrarMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Registrar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegistrarMutation) ResetEdge(name string) error {
	switch name {
	case registrar.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case registrar.EdgeDomain:
		m.ResetDomain()
		return nil
	case registrar.EdgeAsninfo:
		m.ResetAsninfo()
		return nil
	case registrar.EdgeScan:
		m.ResetScan()
		return nil
	case registrar.EdgeWhois:
		m.ResetWhois()
		return nil
	}
	return fmt.Errorf("unknown Registrar edge %s", name)
}

// ScanMutation represents an operation that mutates the Scan nodes in the graph.
type ScanMutation struct {
	config
	op             Op
	typ            string
	id             *int
	scanid         *string
	input          *string
	_type          *string
	timestamp      *time.Time
	clearedFields  map[string]struct{}
	scanjob        map[int]struct{}
	removedscanjob map[int]struct{}
	clearedscanjob bool
	done           bool
	oldValue       func(context.Context) (*Scan, error)
	predicates     []predicate.Scan
}

var _ ent.Mutation = (*ScanMutation)(nil)

// scanOption allows management of the mutation configuration using functional options.
type scanOption func(*ScanMutation)

// newScanMutation creates new mutation for the Scan entity.
func newScanMutation(c config, op Op, opts ...scanOption) *ScanMutation {
	m := &ScanMutation{
		config:        c,
		op:            op,
		typ:           TypeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanID sets the ID field of the mutation.
func withScanID(id int) scanOption {
	return func(m *ScanMutation) {
		var (
			err   error
			once  sync.Once
			value *Scan
		)
		m.oldValue = func(ctx context.Context) (*Scan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScan sets the old Scan of the mutation.
func withScan(node *Scan) scanOption {
	return func(m *ScanMutation) {
		m.oldValue = func(context.Context) (*Scan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScanid sets the "scanid" field.
func (m *ScanMutation) SetScanid(s string) {
	m.scanid = &s
}

// Scanid returns the value of the "scanid" field in the mutation.
func (m *ScanMutation) Scanid() (r string, exists bool) {
	v := m.scanid
	if v == nil {
		return
	}
	return *v, true
}

// OldScanid returns the old "scanid" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldScanid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanid: %w", err)
	}
	return oldValue.Scanid, nil
}

// ResetScanid resets all changes to the "scanid" field.
func (m *ScanMutation) ResetScanid() {
	m.scanid = nil
}

// SetInput sets the "input" field.
func (m *ScanMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *ScanMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *ScanMutation) ResetInput() {
	m.input = nil
}

// SetType sets the "type" field.
func (m *ScanMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScanMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ScanMutation) ResetType() {
	m._type = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *ScanMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ScanMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ScanMutation) ResetTimestamp() {
	m.timestamp = nil
}

// AddScanjobIDs adds the "scanjob" edge to the ScanJob entity by ids.
func (m *ScanMutation) AddScanjobIDs(ids ...int) {
	if m.scanjob == nil {
		m.scanjob = make(map[int]struct{})
	}
	for i := range ids {
		m.scanjob[ids[i]] = struct{}{}
	}
}

// ClearScanjob clears the "scanjob" edge to the ScanJob entity.
func (m *ScanMutation) ClearScanjob() {
	m.clearedscanjob = true
}

// ScanjobCleared reports if the "scanjob" edge to the ScanJob entity was cleared.
func (m *ScanMutation) ScanjobCleared() bool {
	return m.clearedscanjob
}

// RemoveScanjobIDs removes the "scanjob" edge to the ScanJob entity by IDs.
func (m *ScanMutation) RemoveScanjobIDs(ids ...int) {
	if m.removedscanjob == nil {
		m.removedscanjob = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scanjob, ids[i])
		m.removedscanjob[ids[i]] = struct{}{}
	}
}

// RemovedScanjob returns the removed IDs of the "scanjob" edge to the ScanJob entity.
func (m *ScanMutation) RemovedScanjobIDs() (ids []int) {
	for id := range m.removedscanjob {
		ids = append(ids, id)
	}
	return
}

// ScanjobIDs returns the "scanjob" edge IDs in the mutation.
func (m *ScanMutation) ScanjobIDs() (ids []int) {
	for id := range m.scanjob {
		ids = append(ids, id)
	}
	return
}

// ResetScanjob resets all changes to the "scanjob" edge.
func (m *ScanMutation) ResetScanjob() {
	m.scanjob = nil
	m.clearedscanjob = false
	m.removedscanjob = nil
}

// Where appends a list predicates to the ScanMutation builder.
func (m *ScanMutation) Where(ps ...predicate.Scan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scan).
func (m *ScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.scanid != nil {
		fields = append(fields, scan.FieldScanid)
	}
	if m.input != nil {
		fields = append(fields, scan.FieldInput)
	}
	if m._type != nil {
		fields = append(fields, scan.FieldType)
	}
	if m.timestamp != nil {
		fields = append(fields, scan.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldScanid:
		return m.Scanid()
	case scan.FieldInput:
		return m.Input()
	case scan.FieldType:
		return m.GetType()
	case scan.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scan.FieldScanid:
		return m.OldScanid(ctx)
	case scan.FieldInput:
		return m.OldInput(ctx)
	case scan.FieldType:
		return m.OldType(ctx)
	case scan.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Scan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scan.FieldScanid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanid(v)
		return nil
	case scan.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case scan.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case scan.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanMutation) ResetField(name string) error {
	switch name {
	case scan.FieldScanid:
		m.ResetScanid()
		return nil
	case scan.FieldInput:
		m.ResetInput()
		return nil
	case scan.FieldType:
		m.ResetType()
		return nil
	case scan.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.scanjob != nil {
		edges = append(edges, scan.EdgeScanjob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeScanjob:
		ids := make([]ent.Value, 0, len(m.scanjob))
		for id := range m.scanjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedscanjob != nil {
		edges = append(edges, scan.EdgeScanjob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeScanjob:
		ids := make([]ent.Value, 0, len(m.removedscanjob))
		for id := range m.removedscanjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedscanjob {
		edges = append(edges, scan.EdgeScanjob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanMutation) EdgeCleared(name string) bool {
	switch name {
	case scan.EdgeScanjob:
		return m.clearedscanjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanMutation) ResetEdge(name string) error {
	switch name {
	case scan.EdgeScanjob:
		m.ResetScanjob()
		return nil
	}
	return fmt.Errorf("unknown Scan edge %s", name)
}

// ScanJobMutation represents an operation that mutates the ScanJob nodes in the graph.
type ScanJobMutation struct {
	config
	op                Op
	typ               string
	id                *int
	scanid            *string
	timeout           *int
	addtimeout        *int
	status            *scanjob.Status
	input             *string
	output            *string
	command           *string
	timestamp         *time.Time
	clearedFields     map[string]struct{}
	ipaddress         map[int]struct{}
	removedipaddress  map[int]struct{}
	clearedipaddress  bool
	asninfo           map[int]struct{}
	removedasninfo    map[int]struct{}
	clearedasninfo    bool
	dnsentry          map[int]struct{}
	removeddnsentry   map[int]struct{}
	cleareddnsentry   bool
	domain            map[int]struct{}
	removeddomain     map[int]struct{}
	cleareddomain     bool
	_path             map[int]struct{}
	removed_path      map[int]struct{}
	cleared_path      bool
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	registrar         map[int]struct{}
	removedregistrar  map[int]struct{}
	clearedregistrar  bool
	whois             map[int]struct{}
	removedwhois      map[int]struct{}
	clearedwhois      bool
	scan              map[int]struct{}
	removedscan       map[int]struct{}
	clearedscan       bool
	done              bool
	oldValue          func(context.Context) (*ScanJob, error)
	predicates        []predicate.ScanJob
}

var _ ent.Mutation = (*ScanJobMutation)(nil)

// scanjobOption allows management of the mutation configuration using functional options.
type scanjobOption func(*ScanJobMutation)

// newScanJobMutation creates new mutation for the ScanJob entity.
func newScanJobMutation(c config, op Op, opts ...scanjobOption) *ScanJobMutation {
	m := &ScanJobMutation{
		config:        c,
		op:            op,
		typ:           TypeScanJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanJobID sets the ID field of the mutation.
func withScanJobID(id int) scanjobOption {
	return func(m *ScanJobMutation) {
		var (
			err   error
			once  sync.Once
			value *ScanJob
		)
		m.oldValue = func(ctx context.Context) (*ScanJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScanJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScanJob sets the old ScanJob of the mutation.
func withScanJob(node *ScanJob) scanjobOption {
	return func(m *ScanJobMutation) {
		m.oldValue = func(context.Context) (*ScanJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanJobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScanJobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScanJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScanid sets the "scanid" field.
func (m *ScanJobMutation) SetScanid(s string) {
	m.scanid = &s
}

// Scanid returns the value of the "scanid" field in the mutation.
func (m *ScanJobMutation) Scanid() (r string, exists bool) {
	v := m.scanid
	if v == nil {
		return
	}
	return *v, true
}

// OldScanid returns the old "scanid" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldScanid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanid: %w", err)
	}
	return oldValue.Scanid, nil
}

// ResetScanid resets all changes to the "scanid" field.
func (m *ScanJobMutation) ResetScanid() {
	m.scanid = nil
}

// SetTimeout sets the "timeout" field.
func (m *ScanJobMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ScanJobMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ScanJobMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ScanJobMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ScanJobMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetStatus sets the "status" field.
func (m *ScanJobMutation) SetStatus(s scanjob.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScanJobMutation) Status() (r scanjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldStatus(ctx context.Context) (v scanjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScanJobMutation) ResetStatus() {
	m.status = nil
}

// SetInput sets the "input" field.
func (m *ScanJobMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *ScanJobMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *ScanJobMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *ScanJobMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *ScanJobMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *ScanJobMutation) ResetOutput() {
	m.output = nil
}

// SetCommand sets the "command" field.
func (m *ScanJobMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the value of the "command" field in the mutation.
func (m *ScanJobMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ResetCommand resets all changes to the "command" field.
func (m *ScanJobMutation) ResetCommand() {
	m.command = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *ScanJobMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *ScanJobMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the ScanJob entity.
// If the ScanJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanJobMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *ScanJobMutation) ResetTimestamp() {
	m.timestamp = nil
}

// AddIpaddresIDs adds the "ipaddress" edge to the IPAddress entity by ids.
func (m *ScanJobMutation) AddIpaddresIDs(ids ...int) {
	if m.ipaddress == nil {
		m.ipaddress = make(map[int]struct{})
	}
	for i := range ids {
		m.ipaddress[ids[i]] = struct{}{}
	}
}

// ClearIpaddress clears the "ipaddress" edge to the IPAddress entity.
func (m *ScanJobMutation) ClearIpaddress() {
	m.clearedipaddress = true
}

// IpaddressCleared reports if the "ipaddress" edge to the IPAddress entity was cleared.
func (m *ScanJobMutation) IpaddressCleared() bool {
	return m.clearedipaddress
}

// RemoveIpaddresIDs removes the "ipaddress" edge to the IPAddress entity by IDs.
func (m *ScanJobMutation) RemoveIpaddresIDs(ids ...int) {
	if m.removedipaddress == nil {
		m.removedipaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipaddress, ids[i])
		m.removedipaddress[ids[i]] = struct{}{}
	}
}

// RemovedIpaddress returns the removed IDs of the "ipaddress" edge to the IPAddress entity.
func (m *ScanJobMutation) RemovedIpaddressIDs() (ids []int) {
	for id := range m.removedipaddress {
		ids = append(ids, id)
	}
	return
}

// IpaddressIDs returns the "ipaddress" edge IDs in the mutation.
func (m *ScanJobMutation) IpaddressIDs() (ids []int) {
	for id := range m.ipaddress {
		ids = append(ids, id)
	}
	return
}

// ResetIpaddress resets all changes to the "ipaddress" edge.
func (m *ScanJobMutation) ResetIpaddress() {
	m.ipaddress = nil
	m.clearedipaddress = false
	m.removedipaddress = nil
}

// AddAsninfoIDs adds the "asninfo" edge to the ASNInfo entity by ids.
func (m *ScanJobMutation) AddAsninfoIDs(ids ...int) {
	if m.asninfo == nil {
		m.asninfo = make(map[int]struct{})
	}
	for i := range ids {
		m.asninfo[ids[i]] = struct{}{}
	}
}

// ClearAsninfo clears the "asninfo" edge to the ASNInfo entity.
func (m *ScanJobMutation) ClearAsninfo() {
	m.clearedasninfo = true
}

// AsninfoCleared reports if the "asninfo" edge to the ASNInfo entity was cleared.
func (m *ScanJobMutation) AsninfoCleared() bool {
	return m.clearedasninfo
}

// RemoveAsninfoIDs removes the "asninfo" edge to the ASNInfo entity by IDs.
func (m *ScanJobMutation) RemoveAsninfoIDs(ids ...int) {
	if m.removedasninfo == nil {
		m.removedasninfo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asninfo, ids[i])
		m.removedasninfo[ids[i]] = struct{}{}
	}
}

// RemovedAsninfo returns the removed IDs of the "asninfo" edge to the ASNInfo entity.
func (m *ScanJobMutation) RemovedAsninfoIDs() (ids []int) {
	for id := range m.removedasninfo {
		ids = append(ids, id)
	}
	return
}

// AsninfoIDs returns the "asninfo" edge IDs in the mutation.
func (m *ScanJobMutation) AsninfoIDs() (ids []int) {
	for id := range m.asninfo {
		ids = append(ids, id)
	}
	return
}

// ResetAsninfo resets all changes to the "asninfo" edge.
func (m *ScanJobMutation) ResetAsninfo() {
	m.asninfo = nil
	m.clearedasninfo = false
	m.removedasninfo = nil
}

// AddDnsentryIDs adds the "dnsentry" edge to the DNSEntry entity by ids.
func (m *ScanJobMutation) AddDnsentryIDs(ids ...int) {
	if m.dnsentry == nil {
		m.dnsentry = make(map[int]struct{})
	}
	for i := range ids {
		m.dnsentry[ids[i]] = struct{}{}
	}
}

// ClearDnsentry clears the "dnsentry" edge to the DNSEntry entity.
func (m *ScanJobMutation) ClearDnsentry() {
	m.cleareddnsentry = true
}

// DnsentryCleared reports if the "dnsentry" edge to the DNSEntry entity was cleared.
func (m *ScanJobMutation) DnsentryCleared() bool {
	return m.cleareddnsentry
}

// RemoveDnsentryIDs removes the "dnsentry" edge to the DNSEntry entity by IDs.
func (m *ScanJobMutation) RemoveDnsentryIDs(ids ...int) {
	if m.removeddnsentry == nil {
		m.removeddnsentry = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dnsentry, ids[i])
		m.removeddnsentry[ids[i]] = struct{}{}
	}
}

// RemovedDnsentry returns the removed IDs of the "dnsentry" edge to the DNSEntry entity.
func (m *ScanJobMutation) RemovedDnsentryIDs() (ids []int) {
	for id := range m.removeddnsentry {
		ids = append(ids, id)
	}
	return
}

// DnsentryIDs returns the "dnsentry" edge IDs in the mutation.
func (m *ScanJobMutation) DnsentryIDs() (ids []int) {
	for id := range m.dnsentry {
		ids = append(ids, id)
	}
	return
}

// ResetDnsentry resets all changes to the "dnsentry" edge.
func (m *ScanJobMutation) ResetDnsentry() {
	m.dnsentry = nil
	m.cleareddnsentry = false
	m.removeddnsentry = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *ScanJobMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *ScanJobMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *ScanJobMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *ScanJobMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *ScanJobMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *ScanJobMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *ScanJobMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddPathIDs adds the "path" edge to the Path entity by ids.
func (m *ScanJobMutation) AddPathIDs(ids ...int) {
	if m._path == nil {
		m._path = make(map[int]struct{})
	}
	for i := range ids {
		m._path[ids[i]] = struct{}{}
	}
}

// ClearPath clears the "path" edge to the Path entity.
func (m *ScanJobMutation) ClearPath() {
	m.cleared_path = true
}

// PathCleared reports if the "path" edge to the Path entity was cleared.
func (m *ScanJobMutation) PathCleared() bool {
	return m.cleared_path
}

// RemovePathIDs removes the "path" edge to the Path entity by IDs.
func (m *ScanJobMutation) RemovePathIDs(ids ...int) {
	if m.removed_path == nil {
		m.removed_path = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._path, ids[i])
		m.removed_path[ids[i]] = struct{}{}
	}
}

// RemovedPath returns the removed IDs of the "path" edge to the Path entity.
func (m *ScanJobMutation) RemovedPathIDs() (ids []int) {
	for id := range m.removed_path {
		ids = append(ids, id)
	}
	return
}

// PathIDs returns the "path" edge IDs in the mutation.
func (m *ScanJobMutation) PathIDs() (ids []int) {
	for id := range m._path {
		ids = append(ids, id)
	}
	return
}

// ResetPath resets all changes to the "path" edge.
func (m *ScanJobMutation) ResetPath() {
	m._path = nil
	m.cleared_path = false
	m.removed_path = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *ScanJobMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *ScanJobMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *ScanJobMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *ScanJobMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *ScanJobMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *ScanJobMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *ScanJobMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *ScanJobMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *ScanJobMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *ScanJobMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *ScanJobMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *ScanJobMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *ScanJobMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *ScanJobMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddWhoiIDs adds the "whois" edge to the Whois entity by ids.
func (m *ScanJobMutation) AddWhoiIDs(ids ...int) {
	if m.whois == nil {
		m.whois = make(map[int]struct{})
	}
	for i := range ids {
		m.whois[ids[i]] = struct{}{}
	}
}

// ClearWhois clears the "whois" edge to the Whois entity.
func (m *ScanJobMutation) ClearWhois() {
	m.clearedwhois = true
}

// WhoisCleared reports if the "whois" edge to the Whois entity was cleared.
func (m *ScanJobMutation) WhoisCleared() bool {
	return m.clearedwhois
}

// RemoveWhoiIDs removes the "whois" edge to the Whois entity by IDs.
func (m *ScanJobMutation) RemoveWhoiIDs(ids ...int) {
	if m.removedwhois == nil {
		m.removedwhois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.whois, ids[i])
		m.removedwhois[ids[i]] = struct{}{}
	}
}

// RemovedWhois returns the removed IDs of the "whois" edge to the Whois entity.
func (m *ScanJobMutation) RemovedWhoisIDs() (ids []int) {
	for id := range m.removedwhois {
		ids = append(ids, id)
	}
	return
}

// WhoisIDs returns the "whois" edge IDs in the mutation.
func (m *ScanJobMutation) WhoisIDs() (ids []int) {
	for id := range m.whois {
		ids = append(ids, id)
	}
	return
}

// ResetWhois resets all changes to the "whois" edge.
func (m *ScanJobMutation) ResetWhois() {
	m.whois = nil
	m.clearedwhois = false
	m.removedwhois = nil
}

// AddScanIDs adds the "scan" edge to the Scan entity by ids.
func (m *ScanJobMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *ScanJobMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *ScanJobMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the Scan entity by IDs.
func (m *ScanJobMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the Scan entity.
func (m *ScanJobMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *ScanJobMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *ScanJobMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// Where appends a list predicates to the ScanJobMutation builder.
func (m *ScanJobMutation) Where(ps ...predicate.ScanJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScanJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScanJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScanJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScanJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScanJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScanJob).
func (m *ScanJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanJobMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.scanid != nil {
		fields = append(fields, scanjob.FieldScanid)
	}
	if m.timeout != nil {
		fields = append(fields, scanjob.FieldTimeout)
	}
	if m.status != nil {
		fields = append(fields, scanjob.FieldStatus)
	}
	if m.input != nil {
		fields = append(fields, scanjob.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, scanjob.FieldOutput)
	}
	if m.command != nil {
		fields = append(fields, scanjob.FieldCommand)
	}
	if m.timestamp != nil {
		fields = append(fields, scanjob.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scanjob.FieldScanid:
		return m.Scanid()
	case scanjob.FieldTimeout:
		return m.Timeout()
	case scanjob.FieldStatus:
		return m.Status()
	case scanjob.FieldInput:
		return m.Input()
	case scanjob.FieldOutput:
		return m.Output()
	case scanjob.FieldCommand:
		return m.Command()
	case scanjob.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scanjob.FieldScanid:
		return m.OldScanid(ctx)
	case scanjob.FieldTimeout:
		return m.OldTimeout(ctx)
	case scanjob.FieldStatus:
		return m.OldStatus(ctx)
	case scanjob.FieldInput:
		return m.OldInput(ctx)
	case scanjob.FieldOutput:
		return m.OldOutput(ctx)
	case scanjob.FieldCommand:
		return m.OldCommand(ctx)
	case scanjob.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown ScanJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scanjob.FieldScanid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanid(v)
		return nil
	case scanjob.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case scanjob.FieldStatus:
		v, ok := value.(scanjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case scanjob.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case scanjob.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case scanjob.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case scanjob.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown ScanJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanJobMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, scanjob.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scanjob.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scanjob.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown ScanJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanJobMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanJobMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScanJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanJobMutation) ResetField(name string) error {
	switch name {
	case scanjob.FieldScanid:
		m.ResetScanid()
		return nil
	case scanjob.FieldTimeout:
		m.ResetTimeout()
		return nil
	case scanjob.FieldStatus:
		m.ResetStatus()
		return nil
	case scanjob.FieldInput:
		m.ResetInput()
		return nil
	case scanjob.FieldOutput:
		m.ResetOutput()
		return nil
	case scanjob.FieldCommand:
		m.ResetCommand()
		return nil
	case scanjob.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown ScanJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.ipaddress != nil {
		edges = append(edges, scanjob.EdgeIpaddress)
	}
	if m.asninfo != nil {
		edges = append(edges, scanjob.EdgeAsninfo)
	}
	if m.dnsentry != nil {
		edges = append(edges, scanjob.EdgeDnsentry)
	}
	if m.domain != nil {
		edges = append(edges, scanjob.EdgeDomain)
	}
	if m._path != nil {
		edges = append(edges, scanjob.EdgePath)
	}
	if m.nameserver != nil {
		edges = append(edges, scanjob.EdgeNameserver)
	}
	if m.registrar != nil {
		edges = append(edges, scanjob.EdgeRegistrar)
	}
	if m.whois != nil {
		edges = append(edges, scanjob.EdgeWhois)
	}
	if m.scan != nil {
		edges = append(edges, scanjob.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scanjob.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.ipaddress))
		for id := range m.ipaddress {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.asninfo))
		for id := range m.asninfo {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.dnsentry))
		for id := range m.dnsentry {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgePath:
		ids := make([]ent.Value, 0, len(m._path))
		for id := range m._path {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.whois))
		for id := range m.whois {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedipaddress != nil {
		edges = append(edges, scanjob.EdgeIpaddress)
	}
	if m.removedasninfo != nil {
		edges = append(edges, scanjob.EdgeAsninfo)
	}
	if m.removeddnsentry != nil {
		edges = append(edges, scanjob.EdgeDnsentry)
	}
	if m.removeddomain != nil {
		edges = append(edges, scanjob.EdgeDomain)
	}
	if m.removed_path != nil {
		edges = append(edges, scanjob.EdgePath)
	}
	if m.removednameserver != nil {
		edges = append(edges, scanjob.EdgeNameserver)
	}
	if m.removedregistrar != nil {
		edges = append(edges, scanjob.EdgeRegistrar)
	}
	if m.removedwhois != nil {
		edges = append(edges, scanjob.EdgeWhois)
	}
	if m.removedscan != nil {
		edges = append(edges, scanjob.EdgeScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scanjob.EdgeIpaddress:
		ids := make([]ent.Value, 0, len(m.removedipaddress))
		for id := range m.removedipaddress {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeAsninfo:
		ids := make([]ent.Value, 0, len(m.removedasninfo))
		for id := range m.removedasninfo {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeDnsentry:
		ids := make([]ent.Value, 0, len(m.removeddnsentry))
		for id := range m.removeddnsentry {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgePath:
		ids := make([]ent.Value, 0, len(m.removed_path))
		for id := range m.removed_path {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeWhois:
		ids := make([]ent.Value, 0, len(m.removedwhois))
		for id := range m.removedwhois {
			ids = append(ids, id)
		}
		return ids
	case scanjob.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedipaddress {
		edges = append(edges, scanjob.EdgeIpaddress)
	}
	if m.clearedasninfo {
		edges = append(edges, scanjob.EdgeAsninfo)
	}
	if m.cleareddnsentry {
		edges = append(edges, scanjob.EdgeDnsentry)
	}
	if m.cleareddomain {
		edges = append(edges, scanjob.EdgeDomain)
	}
	if m.cleared_path {
		edges = append(edges, scanjob.EdgePath)
	}
	if m.clearednameserver {
		edges = append(edges, scanjob.EdgeNameserver)
	}
	if m.clearedregistrar {
		edges = append(edges, scanjob.EdgeRegistrar)
	}
	if m.clearedwhois {
		edges = append(edges, scanjob.EdgeWhois)
	}
	if m.clearedscan {
		edges = append(edges, scanjob.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanJobMutation) EdgeCleared(name string) bool {
	switch name {
	case scanjob.EdgeIpaddress:
		return m.clearedipaddress
	case scanjob.EdgeAsninfo:
		return m.clearedasninfo
	case scanjob.EdgeDnsentry:
		return m.cleareddnsentry
	case scanjob.EdgeDomain:
		return m.cleareddomain
	case scanjob.EdgePath:
		return m.cleared_path
	case scanjob.EdgeNameserver:
		return m.clearednameserver
	case scanjob.EdgeRegistrar:
		return m.clearedregistrar
	case scanjob.EdgeWhois:
		return m.clearedwhois
	case scanjob.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanJobMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ScanJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanJobMutation) ResetEdge(name string) error {
	switch name {
	case scanjob.EdgeIpaddress:
		m.ResetIpaddress()
		return nil
	case scanjob.EdgeAsninfo:
		m.ResetAsninfo()
		return nil
	case scanjob.EdgeDnsentry:
		m.ResetDnsentry()
		return nil
	case scanjob.EdgeDomain:
		m.ResetDomain()
		return nil
	case scanjob.EdgePath:
		m.ResetPath()
		return nil
	case scanjob.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case scanjob.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case scanjob.EdgeWhois:
		m.ResetWhois()
		return nil
	case scanjob.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown ScanJob edge %s", name)
}

// WhoisMutation represents an operation that mutates the Whois nodes in the graph.
type WhoisMutation struct {
	config
	op                Op
	typ               string
	id                *int
	query             *string
	server            *string
	raw               *string
	country           *string
	created           *time.Time
	updated           *time.Time
	time_first        *time.Time
	time_last         *time.Time
	clearedFields     map[string]struct{}
	iprange           map[int]struct{}
	removediprange    map[int]struct{}
	clearediprange    bool
	domain            map[int]struct{}
	removeddomain     map[int]struct{}
	cleareddomain     bool
	asn               map[int]struct{}
	removedasn        map[int]struct{}
	clearedasn        bool
	registrar         map[int]struct{}
	removedregistrar  map[int]struct{}
	clearedregistrar  bool
	nameserver        map[int]struct{}
	removednameserver map[int]struct{}
	clearednameserver bool
	scan              map[int]struct{}
	removedscan       map[int]struct{}
	clearedscan       bool
	done              bool
	oldValue          func(context.Context) (*Whois, error)
	predicates        []predicate.Whois
}

var _ ent.Mutation = (*WhoisMutation)(nil)

// whoisOption allows management of the mutation configuration using functional options.
type whoisOption func(*WhoisMutation)

// newWhoisMutation creates new mutation for the Whois entity.
func newWhoisMutation(c config, op Op, opts ...whoisOption) *WhoisMutation {
	m := &WhoisMutation{
		config:        c,
		op:            op,
		typ:           TypeWhois,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWhoisID sets the ID field of the mutation.
func withWhoisID(id int) whoisOption {
	return func(m *WhoisMutation) {
		var (
			err   error
			once  sync.Once
			value *Whois
		)
		m.oldValue = func(ctx context.Context) (*Whois, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Whois.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWhois sets the old Whois of the mutation.
func withWhois(node *Whois) whoisOption {
	return func(m *WhoisMutation) {
		m.oldValue = func(context.Context) (*Whois, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WhoisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WhoisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("model_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WhoisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WhoisMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Whois.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuery sets the "query" field.
func (m *WhoisMutation) SetQuery(s string) {
	m.query = &s
}

// Query returns the value of the "query" field in the mutation.
func (m *WhoisMutation) Query() (r string, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ResetQuery resets all changes to the "query" field.
func (m *WhoisMutation) ResetQuery() {
	m.query = nil
}

// SetServer sets the "server" field.
func (m *WhoisMutation) SetServer(s string) {
	m.server = &s
}

// Server returns the value of the "server" field in the mutation.
func (m *WhoisMutation) Server() (r string, exists bool) {
	v := m.server
	if v == nil {
		return
	}
	return *v, true
}

// OldServer returns the old "server" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServer: %w", err)
	}
	return oldValue.Server, nil
}

// ResetServer resets all changes to the "server" field.
func (m *WhoisMutation) ResetServer() {
	m.server = nil
}

// SetRaw sets the "raw" field.
func (m *WhoisMutation) SetRaw(s string) {
	m.raw = &s
}

// Raw returns the value of the "raw" field in the mutation.
func (m *WhoisMutation) Raw() (r string, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ResetRaw resets all changes to the "raw" field.
func (m *WhoisMutation) ResetRaw() {
	m.raw = nil
}

// SetCountry sets the "country" field.
func (m *WhoisMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *WhoisMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *WhoisMutation) ResetCountry() {
	m.country = nil
}

// SetCreated sets the "created" field.
func (m *WhoisMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *WhoisMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *WhoisMutation) ResetCreated() {
	m.created = nil
}

// SetUpdated sets the "updated" field.
func (m *WhoisMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *WhoisMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ResetUpdated resets all changes to the "updated" field.
func (m *WhoisMutation) ResetUpdated() {
	m.updated = nil
}

// SetTimeFirst sets the "time_first" field.
func (m *WhoisMutation) SetTimeFirst(t time.Time) {
	m.time_first = &t
}

// TimeFirst returns the value of the "time_first" field in the mutation.
func (m *WhoisMutation) TimeFirst() (r time.Time, exists bool) {
	v := m.time_first
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFirst returns the old "time_first" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldTimeFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFirst: %w", err)
	}
	return oldValue.TimeFirst, nil
}

// ResetTimeFirst resets all changes to the "time_first" field.
func (m *WhoisMutation) ResetTimeFirst() {
	m.time_first = nil
}

// SetTimeLast sets the "time_last" field.
func (m *WhoisMutation) SetTimeLast(t time.Time) {
	m.time_last = &t
}

// TimeLast returns the value of the "time_last" field in the mutation.
func (m *WhoisMutation) TimeLast() (r time.Time, exists bool) {
	v := m.time_last
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLast returns the old "time_last" field's value of the Whois entity.
// If the Whois object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WhoisMutation) OldTimeLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLast: %w", err)
	}
	return oldValue.TimeLast, nil
}

// ResetTimeLast resets all changes to the "time_last" field.
func (m *WhoisMutation) ResetTimeLast() {
	m.time_last = nil
}

// AddIprangeIDs adds the "iprange" edge to the IPAddress entity by ids.
func (m *WhoisMutation) AddIprangeIDs(ids ...int) {
	if m.iprange == nil {
		m.iprange = make(map[int]struct{})
	}
	for i := range ids {
		m.iprange[ids[i]] = struct{}{}
	}
}

// ClearIprange clears the "iprange" edge to the IPAddress entity.
func (m *WhoisMutation) ClearIprange() {
	m.clearediprange = true
}

// IprangeCleared reports if the "iprange" edge to the IPAddress entity was cleared.
func (m *WhoisMutation) IprangeCleared() bool {
	return m.clearediprange
}

// RemoveIprangeIDs removes the "iprange" edge to the IPAddress entity by IDs.
func (m *WhoisMutation) RemoveIprangeIDs(ids ...int) {
	if m.removediprange == nil {
		m.removediprange = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.iprange, ids[i])
		m.removediprange[ids[i]] = struct{}{}
	}
}

// RemovedIprange returns the removed IDs of the "iprange" edge to the IPAddress entity.
func (m *WhoisMutation) RemovedIprangeIDs() (ids []int) {
	for id := range m.removediprange {
		ids = append(ids, id)
	}
	return
}

// IprangeIDs returns the "iprange" edge IDs in the mutation.
func (m *WhoisMutation) IprangeIDs() (ids []int) {
	for id := range m.iprange {
		ids = append(ids, id)
	}
	return
}

// ResetIprange resets all changes to the "iprange" edge.
func (m *WhoisMutation) ResetIprange() {
	m.iprange = nil
	m.clearediprange = false
	m.removediprange = nil
}

// AddDomainIDs adds the "domain" edge to the Domain entity by ids.
func (m *WhoisMutation) AddDomainIDs(ids ...int) {
	if m.domain == nil {
		m.domain = make(map[int]struct{})
	}
	for i := range ids {
		m.domain[ids[i]] = struct{}{}
	}
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *WhoisMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *WhoisMutation) DomainCleared() bool {
	return m.cleareddomain
}

// RemoveDomainIDs removes the "domain" edge to the Domain entity by IDs.
func (m *WhoisMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomain == nil {
		m.removeddomain = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domain, ids[i])
		m.removeddomain[ids[i]] = struct{}{}
	}
}

// RemovedDomain returns the removed IDs of the "domain" edge to the Domain entity.
func (m *WhoisMutation) RemovedDomainIDs() (ids []int) {
	for id := range m.removeddomain {
		ids = append(ids, id)
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
func (m *WhoisMutation) DomainIDs() (ids []int) {
	for id := range m.domain {
		ids = append(ids, id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *WhoisMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
	m.removeddomain = nil
}

// AddAsnIDs adds the "asn" edge to the ASNInfo entity by ids.
func (m *WhoisMutation) AddAsnIDs(ids ...int) {
	if m.asn == nil {
		m.asn = make(map[int]struct{})
	}
	for i := range ids {
		m.asn[ids[i]] = struct{}{}
	}
}

// ClearAsn clears the "asn" edge to the ASNInfo entity.
func (m *WhoisMutation) ClearAsn() {
	m.clearedasn = true
}

// AsnCleared reports if the "asn" edge to the ASNInfo entity was cleared.
func (m *WhoisMutation) AsnCleared() bool {
	return m.clearedasn
}

// RemoveAsnIDs removes the "asn" edge to the ASNInfo entity by IDs.
func (m *WhoisMutation) RemoveAsnIDs(ids ...int) {
	if m.removedasn == nil {
		m.removedasn = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.asn, ids[i])
		m.removedasn[ids[i]] = struct{}{}
	}
}

// RemovedAsn returns the removed IDs of the "asn" edge to the ASNInfo entity.
func (m *WhoisMutation) RemovedAsnIDs() (ids []int) {
	for id := range m.removedasn {
		ids = append(ids, id)
	}
	return
}

// AsnIDs returns the "asn" edge IDs in the mutation.
func (m *WhoisMutation) AsnIDs() (ids []int) {
	for id := range m.asn {
		ids = append(ids, id)
	}
	return
}

// ResetAsn resets all changes to the "asn" edge.
func (m *WhoisMutation) ResetAsn() {
	m.asn = nil
	m.clearedasn = false
	m.removedasn = nil
}

// AddRegistrarIDs adds the "registrar" edge to the Registrar entity by ids.
func (m *WhoisMutation) AddRegistrarIDs(ids ...int) {
	if m.registrar == nil {
		m.registrar = make(map[int]struct{})
	}
	for i := range ids {
		m.registrar[ids[i]] = struct{}{}
	}
}

// ClearRegistrar clears the "registrar" edge to the Registrar entity.
func (m *WhoisMutation) ClearRegistrar() {
	m.clearedregistrar = true
}

// RegistrarCleared reports if the "registrar" edge to the Registrar entity was cleared.
func (m *WhoisMutation) RegistrarCleared() bool {
	return m.clearedregistrar
}

// RemoveRegistrarIDs removes the "registrar" edge to the Registrar entity by IDs.
func (m *WhoisMutation) RemoveRegistrarIDs(ids ...int) {
	if m.removedregistrar == nil {
		m.removedregistrar = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrar, ids[i])
		m.removedregistrar[ids[i]] = struct{}{}
	}
}

// RemovedRegistrar returns the removed IDs of the "registrar" edge to the Registrar entity.
func (m *WhoisMutation) RemovedRegistrarIDs() (ids []int) {
	for id := range m.removedregistrar {
		ids = append(ids, id)
	}
	return
}

// RegistrarIDs returns the "registrar" edge IDs in the mutation.
func (m *WhoisMutation) RegistrarIDs() (ids []int) {
	for id := range m.registrar {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrar resets all changes to the "registrar" edge.
func (m *WhoisMutation) ResetRegistrar() {
	m.registrar = nil
	m.clearedregistrar = false
	m.removedregistrar = nil
}

// AddNameserverIDs adds the "nameserver" edge to the Nameserver entity by ids.
func (m *WhoisMutation) AddNameserverIDs(ids ...int) {
	if m.nameserver == nil {
		m.nameserver = make(map[int]struct{})
	}
	for i := range ids {
		m.nameserver[ids[i]] = struct{}{}
	}
}

// ClearNameserver clears the "nameserver" edge to the Nameserver entity.
func (m *WhoisMutation) ClearNameserver() {
	m.clearednameserver = true
}

// NameserverCleared reports if the "nameserver" edge to the Nameserver entity was cleared.
func (m *WhoisMutation) NameserverCleared() bool {
	return m.clearednameserver
}

// RemoveNameserverIDs removes the "nameserver" edge to the Nameserver entity by IDs.
func (m *WhoisMutation) RemoveNameserverIDs(ids ...int) {
	if m.removednameserver == nil {
		m.removednameserver = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nameserver, ids[i])
		m.removednameserver[ids[i]] = struct{}{}
	}
}

// RemovedNameserver returns the removed IDs of the "nameserver" edge to the Nameserver entity.
func (m *WhoisMutation) RemovedNameserverIDs() (ids []int) {
	for id := range m.removednameserver {
		ids = append(ids, id)
	}
	return
}

// NameserverIDs returns the "nameserver" edge IDs in the mutation.
func (m *WhoisMutation) NameserverIDs() (ids []int) {
	for id := range m.nameserver {
		ids = append(ids, id)
	}
	return
}

// ResetNameserver resets all changes to the "nameserver" edge.
func (m *WhoisMutation) ResetNameserver() {
	m.nameserver = nil
	m.clearednameserver = false
	m.removednameserver = nil
}

// AddScanIDs adds the "scan" edge to the ScanJob entity by ids.
func (m *WhoisMutation) AddScanIDs(ids ...int) {
	if m.scan == nil {
		m.scan = make(map[int]struct{})
	}
	for i := range ids {
		m.scan[ids[i]] = struct{}{}
	}
}

// ClearScan clears the "scan" edge to the ScanJob entity.
func (m *WhoisMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the ScanJob entity was cleared.
func (m *WhoisMutation) ScanCleared() bool {
	return m.clearedscan
}

// RemoveScanIDs removes the "scan" edge to the ScanJob entity by IDs.
func (m *WhoisMutation) RemoveScanIDs(ids ...int) {
	if m.removedscan == nil {
		m.removedscan = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scan, ids[i])
		m.removedscan[ids[i]] = struct{}{}
	}
}

// RemovedScan returns the removed IDs of the "scan" edge to the ScanJob entity.
func (m *WhoisMutation) RemovedScanIDs() (ids []int) {
	for id := range m.removedscan {
		ids = append(ids, id)
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
func (m *WhoisMutation) ScanIDs() (ids []int) {
	for id := range m.scan {
		ids = append(ids, id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *WhoisMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
	m.removedscan = nil
}

// Where appends a list predicates to the WhoisMutation builder.
func (m *WhoisMutation) Where(ps ...predicate.Whois) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WhoisMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WhoisMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Whois, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WhoisMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WhoisMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Whois).
func (m *WhoisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WhoisMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.query != nil {
		fields = append(fields, whois.FieldQuery)
	}
	if m.server != nil {
		fields = append(fields, whois.FieldServer)
	}
	if m.raw != nil {
		fields = append(fields, whois.FieldRaw)
	}
	if m.country != nil {
		fields = append(fields, whois.FieldCountry)
	}
	if m.created != nil {
		fields = append(fields, whois.FieldCreated)
	}
	if m.updated != nil {
		fields = append(fields, whois.FieldUpdated)
	}
	if m.time_first != nil {
		fields = append(fields, whois.FieldTimeFirst)
	}
	if m.time_last != nil {
		fields = append(fields, whois.FieldTimeLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WhoisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case whois.FieldQuery:
		return m.Query()
	case whois.FieldServer:
		return m.Server()
	case whois.FieldRaw:
		return m.Raw()
	case whois.FieldCountry:
		return m.Country()
	case whois.FieldCreated:
		return m.Created()
	case whois.FieldUpdated:
		return m.Updated()
	case whois.FieldTimeFirst:
		return m.TimeFirst()
	case whois.FieldTimeLast:
		return m.TimeLast()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WhoisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case whois.FieldQuery:
		return m.OldQuery(ctx)
	case whois.FieldServer:
		return m.OldServer(ctx)
	case whois.FieldRaw:
		return m.OldRaw(ctx)
	case whois.FieldCountry:
		return m.OldCountry(ctx)
	case whois.FieldCreated:
		return m.OldCreated(ctx)
	case whois.FieldUpdated:
		return m.OldUpdated(ctx)
	case whois.FieldTimeFirst:
		return m.OldTimeFirst(ctx)
	case whois.FieldTimeLast:
		return m.OldTimeLast(ctx)
	}
	return nil, fmt.Errorf("unknown Whois field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WhoisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case whois.FieldQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case whois.FieldServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServer(v)
		return nil
	case whois.FieldRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	case whois.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case whois.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case whois.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case whois.FieldTimeFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFirst(v)
		return nil
	case whois.FieldTimeLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLast(v)
		return nil
	}
	return fmt.Errorf("unknown Whois field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WhoisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WhoisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WhoisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Whois numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WhoisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WhoisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WhoisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Whois nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WhoisMutation) ResetField(name string) error {
	switch name {
	case whois.FieldQuery:
		m.ResetQuery()
		return nil
	case whois.FieldServer:
		m.ResetServer()
		return nil
	case whois.FieldRaw:
		m.ResetRaw()
		return nil
	case whois.FieldCountry:
		m.ResetCountry()
		return nil
	case whois.FieldCreated:
		m.ResetCreated()
		return nil
	case whois.FieldUpdated:
		m.ResetUpdated()
		return nil
	case whois.FieldTimeFirst:
		m.ResetTimeFirst()
		return nil
	case whois.FieldTimeLast:
		m.ResetTimeLast()
		return nil
	}
	return fmt.Errorf("unknown Whois field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WhoisMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.iprange != nil {
		edges = append(edges, whois.EdgeIprange)
	}
	if m.domain != nil {
		edges = append(edges, whois.EdgeDomain)
	}
	if m.asn != nil {
		edges = append(edges, whois.EdgeAsn)
	}
	if m.registrar != nil {
		edges = append(edges, whois.EdgeRegistrar)
	}
	if m.nameserver != nil {
		edges = append(edges, whois.EdgeNameserver)
	}
	if m.scan != nil {
		edges = append(edges, whois.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WhoisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case whois.EdgeIprange:
		ids := make([]ent.Value, 0, len(m.iprange))
		for id := range m.iprange {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.domain))
		for id := range m.domain {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeAsn:
		ids := make([]ent.Value, 0, len(m.asn))
		for id := range m.asn {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.registrar))
		for id := range m.registrar {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.nameserver))
		for id := range m.nameserver {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeScan:
		ids := make([]ent.Value, 0, len(m.scan))
		for id := range m.scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WhoisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removediprange != nil {
		edges = append(edges, whois.EdgeIprange)
	}
	if m.removeddomain != nil {
		edges = append(edges, whois.EdgeDomain)
	}
	if m.removedasn != nil {
		edges = append(edges, whois.EdgeAsn)
	}
	if m.removedregistrar != nil {
		edges = append(edges, whois.EdgeRegistrar)
	}
	if m.removednameserver != nil {
		edges = append(edges, whois.EdgeNameserver)
	}
	if m.removedscan != nil {
		edges = append(edges, whois.EdgeScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WhoisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case whois.EdgeIprange:
		ids := make([]ent.Value, 0, len(m.removediprange))
		for id := range m.removediprange {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeDomain:
		ids := make([]ent.Value, 0, len(m.removeddomain))
		for id := range m.removeddomain {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeAsn:
		ids := make([]ent.Value, 0, len(m.removedasn))
		for id := range m.removedasn {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeRegistrar:
		ids := make([]ent.Value, 0, len(m.removedregistrar))
		for id := range m.removedregistrar {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeNameserver:
		ids := make([]ent.Value, 0, len(m.removednameserver))
		for id := range m.removednameserver {
			ids = append(ids, id)
		}
		return ids
	case whois.EdgeScan:
		ids := make([]ent.Value, 0, len(m.removedscan))
		for id := range m.removedscan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WhoisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearediprange {
		edges = append(edges, whois.EdgeIprange)
	}
	if m.cleareddomain {
		edges = append(edges, whois.EdgeDomain)
	}
	if m.clearedasn {
		edges = append(edges, whois.EdgeAsn)
	}
	if m.clearedregistrar {
		edges = append(edges, whois.EdgeRegistrar)
	}
	if m.clearednameserver {
		edges = append(edges, whois.EdgeNameserver)
	}
	if m.clearedscan {
		edges = append(edges, whois.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WhoisMutation) EdgeCleared(name string) bool {
	switch name {
	case whois.EdgeIprange:
		return m.clearediprange
	case whois.EdgeDomain:
		return m.cleareddomain
	case whois.EdgeAsn:
		return m.clearedasn
	case whois.EdgeRegistrar:
		return m.clearedregistrar
	case whois.EdgeNameserver:
		return m.clearednameserver
	case whois.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WhoisMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Whois unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WhoisMutation) ResetEdge(name string) error {
	switch name {
	case whois.EdgeIprange:
		m.ResetIprange()
		return nil
	case whois.EdgeDomain:
		m.ResetDomain()
		return nil
	case whois.EdgeAsn:
		m.ResetAsn()
		return nil
	case whois.EdgeRegistrar:
		m.ResetRegistrar()
		return nil
	case whois.EdgeNameserver:
		m.ResetNameserver()
		return nil
	case whois.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown Whois edge %s", name)
}

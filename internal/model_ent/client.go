// Code generated by ent, DO NOT EDIT.

package model_ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/ice-bergtech/dnh/src/internal/model_ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/asninfo"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/dnsentry"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/domain"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/ipaddress"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/nameserver"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/path"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/registrar"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/scan"
	"github.com/ice-bergtech/dnh/src/internal/model_ent/whois"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ASNInfo is the client for interacting with the ASNInfo builders.
	ASNInfo *ASNInfoClient
	// DNSEntry is the client for interacting with the DNSEntry builders.
	DNSEntry *DNSEntryClient
	// Domain is the client for interacting with the Domain builders.
	Domain *DomainClient
	// IPAddress is the client for interacting with the IPAddress builders.
	IPAddress *IPAddressClient
	// Nameserver is the client for interacting with the Nameserver builders.
	Nameserver *NameserverClient
	// Path is the client for interacting with the Path builders.
	Path *PathClient
	// Registrar is the client for interacting with the Registrar builders.
	Registrar *RegistrarClient
	// Scan is the client for interacting with the Scan builders.
	Scan *ScanClient
	// Whois is the client for interacting with the Whois builders.
	Whois *WhoisClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ASNInfo = NewASNInfoClient(c.config)
	c.DNSEntry = NewDNSEntryClient(c.config)
	c.Domain = NewDomainClient(c.config)
	c.IPAddress = NewIPAddressClient(c.config)
	c.Nameserver = NewNameserverClient(c.config)
	c.Path = NewPathClient(c.config)
	c.Registrar = NewRegistrarClient(c.config)
	c.Scan = NewScanClient(c.config)
	c.Whois = NewWhoisClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("model_ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("model_ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		ASNInfo:    NewASNInfoClient(cfg),
		DNSEntry:   NewDNSEntryClient(cfg),
		Domain:     NewDomainClient(cfg),
		IPAddress:  NewIPAddressClient(cfg),
		Nameserver: NewNameserverClient(cfg),
		Path:       NewPathClient(cfg),
		Registrar:  NewRegistrarClient(cfg),
		Scan:       NewScanClient(cfg),
		Whois:      NewWhoisClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		ASNInfo:    NewASNInfoClient(cfg),
		DNSEntry:   NewDNSEntryClient(cfg),
		Domain:     NewDomainClient(cfg),
		IPAddress:  NewIPAddressClient(cfg),
		Nameserver: NewNameserverClient(cfg),
		Path:       NewPathClient(cfg),
		Registrar:  NewRegistrarClient(cfg),
		Scan:       NewScanClient(cfg),
		Whois:      NewWhoisClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ASNInfo.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ASNInfo, c.DNSEntry, c.Domain, c.IPAddress, c.Nameserver, c.Path, c.Registrar,
		c.Scan, c.Whois,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ASNInfo, c.DNSEntry, c.Domain, c.IPAddress, c.Nameserver, c.Path, c.Registrar,
		c.Scan, c.Whois,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ASNInfoMutation:
		return c.ASNInfo.mutate(ctx, m)
	case *DNSEntryMutation:
		return c.DNSEntry.mutate(ctx, m)
	case *DomainMutation:
		return c.Domain.mutate(ctx, m)
	case *IPAddressMutation:
		return c.IPAddress.mutate(ctx, m)
	case *NameserverMutation:
		return c.Nameserver.mutate(ctx, m)
	case *PathMutation:
		return c.Path.mutate(ctx, m)
	case *RegistrarMutation:
		return c.Registrar.mutate(ctx, m)
	case *ScanMutation:
		return c.Scan.mutate(ctx, m)
	case *WhoisMutation:
		return c.Whois.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("model_ent: unknown mutation type %T", m)
	}
}

// ASNInfoClient is a client for the ASNInfo schema.
type ASNInfoClient struct {
	config
}

// NewASNInfoClient returns a client for the ASNInfo from the given config.
func NewASNInfoClient(c config) *ASNInfoClient {
	return &ASNInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asninfo.Hooks(f(g(h())))`.
func (c *ASNInfoClient) Use(hooks ...Hook) {
	c.hooks.ASNInfo = append(c.hooks.ASNInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asninfo.Intercept(f(g(h())))`.
func (c *ASNInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.ASNInfo = append(c.inters.ASNInfo, interceptors...)
}

// Create returns a builder for creating a ASNInfo entity.
func (c *ASNInfoClient) Create() *ASNInfoCreate {
	mutation := newASNInfoMutation(c.config, OpCreate)
	return &ASNInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ASNInfo entities.
func (c *ASNInfoClient) CreateBulk(builders ...*ASNInfoCreate) *ASNInfoCreateBulk {
	return &ASNInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ASNInfoClient) MapCreateBulk(slice any, setFunc func(*ASNInfoCreate, int)) *ASNInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ASNInfoCreateBulk{err: fmt.Errorf("calling to ASNInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ASNInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ASNInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ASNInfo.
func (c *ASNInfoClient) Update() *ASNInfoUpdate {
	mutation := newASNInfoMutation(c.config, OpUpdate)
	return &ASNInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ASNInfoClient) UpdateOne(ai *ASNInfo) *ASNInfoUpdateOne {
	mutation := newASNInfoMutation(c.config, OpUpdateOne, withASNInfo(ai))
	return &ASNInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ASNInfoClient) UpdateOneID(id int) *ASNInfoUpdateOne {
	mutation := newASNInfoMutation(c.config, OpUpdateOne, withASNInfoID(id))
	return &ASNInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ASNInfo.
func (c *ASNInfoClient) Delete() *ASNInfoDelete {
	mutation := newASNInfoMutation(c.config, OpDelete)
	return &ASNInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ASNInfoClient) DeleteOne(ai *ASNInfo) *ASNInfoDeleteOne {
	return c.DeleteOneID(ai.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ASNInfoClient) DeleteOneID(id int) *ASNInfoDeleteOne {
	builder := c.Delete().Where(asninfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ASNInfoDeleteOne{builder}
}

// Query returns a query builder for ASNInfo.
func (c *ASNInfoClient) Query() *ASNInfoQuery {
	return &ASNInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeASNInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a ASNInfo entity by its id.
func (c *ASNInfoClient) Get(ctx context.Context, id int) (*ASNInfo, error) {
	return c.Query().Where(asninfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ASNInfoClient) GetX(ctx context.Context, id int) *ASNInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ASNInfoClient) Hooks() []Hook {
	return c.hooks.ASNInfo
}

// Interceptors returns the client interceptors.
func (c *ASNInfoClient) Interceptors() []Interceptor {
	return c.inters.ASNInfo
}

func (c *ASNInfoClient) mutate(ctx context.Context, m *ASNInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ASNInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ASNInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ASNInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ASNInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown ASNInfo mutation op: %q", m.Op())
	}
}

// DNSEntryClient is a client for the DNSEntry schema.
type DNSEntryClient struct {
	config
}

// NewDNSEntryClient returns a client for the DNSEntry from the given config.
func NewDNSEntryClient(c config) *DNSEntryClient {
	return &DNSEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsentry.Hooks(f(g(h())))`.
func (c *DNSEntryClient) Use(hooks ...Hook) {
	c.hooks.DNSEntry = append(c.hooks.DNSEntry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsentry.Intercept(f(g(h())))`.
func (c *DNSEntryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNSEntry = append(c.inters.DNSEntry, interceptors...)
}

// Create returns a builder for creating a DNSEntry entity.
func (c *DNSEntryClient) Create() *DNSEntryCreate {
	mutation := newDNSEntryMutation(c.config, OpCreate)
	return &DNSEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNSEntry entities.
func (c *DNSEntryClient) CreateBulk(builders ...*DNSEntryCreate) *DNSEntryCreateBulk {
	return &DNSEntryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSEntryClient) MapCreateBulk(slice any, setFunc func(*DNSEntryCreate, int)) *DNSEntryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSEntryCreateBulk{err: fmt.Errorf("calling to DNSEntryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSEntryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNSEntry.
func (c *DNSEntryClient) Update() *DNSEntryUpdate {
	mutation := newDNSEntryMutation(c.config, OpUpdate)
	return &DNSEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSEntryClient) UpdateOne(de *DNSEntry) *DNSEntryUpdateOne {
	mutation := newDNSEntryMutation(c.config, OpUpdateOne, withDNSEntry(de))
	return &DNSEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSEntryClient) UpdateOneID(id int) *DNSEntryUpdateOne {
	mutation := newDNSEntryMutation(c.config, OpUpdateOne, withDNSEntryID(id))
	return &DNSEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNSEntry.
func (c *DNSEntryClient) Delete() *DNSEntryDelete {
	mutation := newDNSEntryMutation(c.config, OpDelete)
	return &DNSEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSEntryClient) DeleteOne(de *DNSEntry) *DNSEntryDeleteOne {
	return c.DeleteOneID(de.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSEntryClient) DeleteOneID(id int) *DNSEntryDeleteOne {
	builder := c.Delete().Where(dnsentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSEntryDeleteOne{builder}
}

// Query returns a query builder for DNSEntry.
func (c *DNSEntryClient) Query() *DNSEntryQuery {
	return &DNSEntryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNSEntry},
		inters: c.Interceptors(),
	}
}

// Get returns a DNSEntry entity by its id.
func (c *DNSEntryClient) Get(ctx context.Context, id int) (*DNSEntry, error) {
	return c.Query().Where(dnsentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSEntryClient) GetX(ctx context.Context, id int) *DNSEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DNSEntryClient) Hooks() []Hook {
	return c.hooks.DNSEntry
}

// Interceptors returns the client interceptors.
func (c *DNSEntryClient) Interceptors() []Interceptor {
	return c.inters.DNSEntry
}

func (c *DNSEntryClient) mutate(ctx context.Context, m *DNSEntryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSEntryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSEntryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown DNSEntry mutation op: %q", m.Op())
	}
}

// DomainClient is a client for the Domain schema.
type DomainClient struct {
	config
}

// NewDomainClient returns a client for the Domain from the given config.
func NewDomainClient(c config) *DomainClient {
	return &DomainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `domain.Hooks(f(g(h())))`.
func (c *DomainClient) Use(hooks ...Hook) {
	c.hooks.Domain = append(c.hooks.Domain, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `domain.Intercept(f(g(h())))`.
func (c *DomainClient) Intercept(interceptors ...Interceptor) {
	c.inters.Domain = append(c.inters.Domain, interceptors...)
}

// Create returns a builder for creating a Domain entity.
func (c *DomainClient) Create() *DomainCreate {
	mutation := newDomainMutation(c.config, OpCreate)
	return &DomainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Domain entities.
func (c *DomainClient) CreateBulk(builders ...*DomainCreate) *DomainCreateBulk {
	return &DomainCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DomainClient) MapCreateBulk(slice any, setFunc func(*DomainCreate, int)) *DomainCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DomainCreateBulk{err: fmt.Errorf("calling to DomainClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DomainCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DomainCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Domain.
func (c *DomainClient) Update() *DomainUpdate {
	mutation := newDomainMutation(c.config, OpUpdate)
	return &DomainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DomainClient) UpdateOne(d *Domain) *DomainUpdateOne {
	mutation := newDomainMutation(c.config, OpUpdateOne, withDomain(d))
	return &DomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DomainClient) UpdateOneID(id int) *DomainUpdateOne {
	mutation := newDomainMutation(c.config, OpUpdateOne, withDomainID(id))
	return &DomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Domain.
func (c *DomainClient) Delete() *DomainDelete {
	mutation := newDomainMutation(c.config, OpDelete)
	return &DomainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DomainClient) DeleteOne(d *Domain) *DomainDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DomainClient) DeleteOneID(id int) *DomainDeleteOne {
	builder := c.Delete().Where(domain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DomainDeleteOne{builder}
}

// Query returns a query builder for Domain.
func (c *DomainClient) Query() *DomainQuery {
	return &DomainQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDomain},
		inters: c.Interceptors(),
	}
}

// Get returns a Domain entity by its id.
func (c *DomainClient) Get(ctx context.Context, id int) (*Domain, error) {
	return c.Query().Where(domain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DomainClient) GetX(ctx context.Context, id int) *Domain {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNameserver queries the nameserver edge of a Domain.
func (c *DomainClient) QueryNameserver(d *Domain) *NameserverQuery {
	query := (&NameserverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(nameserver.Table, nameserver.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, domain.NameserverTable, domain.NameserverColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDomain queries the domain edge of a Domain.
func (c *DomainClient) QueryDomain(d *Domain) *DomainQuery {
	query := (&DomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, domain.DomainTable, domain.DomainPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDnsentry queries the dnsentry edge of a Domain.
func (c *DomainClient) QueryDnsentry(d *Domain) *DNSEntryQuery {
	query := (&DNSEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(dnsentry.Table, dnsentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, domain.DnsentryTable, domain.DnsentryColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIpaddress queries the ipaddress edge of a Domain.
func (c *DomainClient) QueryIpaddress(d *Domain) *IPAddressQuery {
	query := (&IPAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, domain.IpaddressTable, domain.IpaddressColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPath queries the path edge of a Domain.
func (c *DomainClient) QueryPath(d *Domain) *PathQuery {
	query := (&PathClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(domain.Table, domain.FieldID, id),
			sqlgraph.To(path.Table, path.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, domain.PathTable, domain.PathColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DomainClient) Hooks() []Hook {
	return c.hooks.Domain
}

// Interceptors returns the client interceptors.
func (c *DomainClient) Interceptors() []Interceptor {
	return c.inters.Domain
}

func (c *DomainClient) mutate(ctx context.Context, m *DomainMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DomainCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DomainUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DomainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DomainDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Domain mutation op: %q", m.Op())
	}
}

// IPAddressClient is a client for the IPAddress schema.
type IPAddressClient struct {
	config
}

// NewIPAddressClient returns a client for the IPAddress from the given config.
func NewIPAddressClient(c config) *IPAddressClient {
	return &IPAddressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ipaddress.Hooks(f(g(h())))`.
func (c *IPAddressClient) Use(hooks ...Hook) {
	c.hooks.IPAddress = append(c.hooks.IPAddress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ipaddress.Intercept(f(g(h())))`.
func (c *IPAddressClient) Intercept(interceptors ...Interceptor) {
	c.inters.IPAddress = append(c.inters.IPAddress, interceptors...)
}

// Create returns a builder for creating a IPAddress entity.
func (c *IPAddressClient) Create() *IPAddressCreate {
	mutation := newIPAddressMutation(c.config, OpCreate)
	return &IPAddressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IPAddress entities.
func (c *IPAddressClient) CreateBulk(builders ...*IPAddressCreate) *IPAddressCreateBulk {
	return &IPAddressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IPAddressClient) MapCreateBulk(slice any, setFunc func(*IPAddressCreate, int)) *IPAddressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IPAddressCreateBulk{err: fmt.Errorf("calling to IPAddressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IPAddressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IPAddressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IPAddress.
func (c *IPAddressClient) Update() *IPAddressUpdate {
	mutation := newIPAddressMutation(c.config, OpUpdate)
	return &IPAddressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IPAddressClient) UpdateOne(ia *IPAddress) *IPAddressUpdateOne {
	mutation := newIPAddressMutation(c.config, OpUpdateOne, withIPAddress(ia))
	return &IPAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IPAddressClient) UpdateOneID(id int) *IPAddressUpdateOne {
	mutation := newIPAddressMutation(c.config, OpUpdateOne, withIPAddressID(id))
	return &IPAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IPAddress.
func (c *IPAddressClient) Delete() *IPAddressDelete {
	mutation := newIPAddressMutation(c.config, OpDelete)
	return &IPAddressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IPAddressClient) DeleteOne(ia *IPAddress) *IPAddressDeleteOne {
	return c.DeleteOneID(ia.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IPAddressClient) DeleteOneID(id int) *IPAddressDeleteOne {
	builder := c.Delete().Where(ipaddress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IPAddressDeleteOne{builder}
}

// Query returns a query builder for IPAddress.
func (c *IPAddressClient) Query() *IPAddressQuery {
	return &IPAddressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIPAddress},
		inters: c.Interceptors(),
	}
}

// Get returns a IPAddress entity by its id.
func (c *IPAddressClient) Get(ctx context.Context, id int) (*IPAddress, error) {
	return c.Query().Where(ipaddress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IPAddressClient) GetX(ctx context.Context, id int) *IPAddress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsninfo queries the asninfo edge of a IPAddress.
func (c *IPAddressClient) QueryAsninfo(ia *IPAddress) *ASNInfoQuery {
	query := (&ASNInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ia.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ipaddress.Table, ipaddress.FieldID, id),
			sqlgraph.To(asninfo.Table, asninfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ipaddress.AsninfoTable, ipaddress.AsninfoColumn),
		)
		fromV = sqlgraph.Neighbors(ia.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IPAddressClient) Hooks() []Hook {
	return c.hooks.IPAddress
}

// Interceptors returns the client interceptors.
func (c *IPAddressClient) Interceptors() []Interceptor {
	return c.inters.IPAddress
}

func (c *IPAddressClient) mutate(ctx context.Context, m *IPAddressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IPAddressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IPAddressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IPAddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IPAddressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown IPAddress mutation op: %q", m.Op())
	}
}

// NameserverClient is a client for the Nameserver schema.
type NameserverClient struct {
	config
}

// NewNameserverClient returns a client for the Nameserver from the given config.
func NewNameserverClient(c config) *NameserverClient {
	return &NameserverClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nameserver.Hooks(f(g(h())))`.
func (c *NameserverClient) Use(hooks ...Hook) {
	c.hooks.Nameserver = append(c.hooks.Nameserver, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nameserver.Intercept(f(g(h())))`.
func (c *NameserverClient) Intercept(interceptors ...Interceptor) {
	c.inters.Nameserver = append(c.inters.Nameserver, interceptors...)
}

// Create returns a builder for creating a Nameserver entity.
func (c *NameserverClient) Create() *NameserverCreate {
	mutation := newNameserverMutation(c.config, OpCreate)
	return &NameserverCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Nameserver entities.
func (c *NameserverClient) CreateBulk(builders ...*NameserverCreate) *NameserverCreateBulk {
	return &NameserverCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NameserverClient) MapCreateBulk(slice any, setFunc func(*NameserverCreate, int)) *NameserverCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NameserverCreateBulk{err: fmt.Errorf("calling to NameserverClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NameserverCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NameserverCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Nameserver.
func (c *NameserverClient) Update() *NameserverUpdate {
	mutation := newNameserverMutation(c.config, OpUpdate)
	return &NameserverUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NameserverClient) UpdateOne(n *Nameserver) *NameserverUpdateOne {
	mutation := newNameserverMutation(c.config, OpUpdateOne, withNameserver(n))
	return &NameserverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NameserverClient) UpdateOneID(id int) *NameserverUpdateOne {
	mutation := newNameserverMutation(c.config, OpUpdateOne, withNameserverID(id))
	return &NameserverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Nameserver.
func (c *NameserverClient) Delete() *NameserverDelete {
	mutation := newNameserverMutation(c.config, OpDelete)
	return &NameserverDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NameserverClient) DeleteOne(n *Nameserver) *NameserverDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NameserverClient) DeleteOneID(id int) *NameserverDeleteOne {
	builder := c.Delete().Where(nameserver.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NameserverDeleteOne{builder}
}

// Query returns a query builder for Nameserver.
func (c *NameserverClient) Query() *NameserverQuery {
	return &NameserverQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNameserver},
		inters: c.Interceptors(),
	}
}

// Get returns a Nameserver entity by its id.
func (c *NameserverClient) Get(ctx context.Context, id int) (*Nameserver, error) {
	return c.Query().Where(nameserver.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NameserverClient) GetX(ctx context.Context, id int) *Nameserver {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIpaddress queries the ipaddress edge of a Nameserver.
func (c *NameserverClient) QueryIpaddress(n *Nameserver) *IPAddressQuery {
	query := (&IPAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nameserver.Table, nameserver.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, nameserver.IpaddressTable, nameserver.IpaddressColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NameserverClient) Hooks() []Hook {
	return c.hooks.Nameserver
}

// Interceptors returns the client interceptors.
func (c *NameserverClient) Interceptors() []Interceptor {
	return c.inters.Nameserver
}

func (c *NameserverClient) mutate(ctx context.Context, m *NameserverMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NameserverCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NameserverUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NameserverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NameserverDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Nameserver mutation op: %q", m.Op())
	}
}

// PathClient is a client for the Path schema.
type PathClient struct {
	config
}

// NewPathClient returns a client for the Path from the given config.
func NewPathClient(c config) *PathClient {
	return &PathClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `path.Hooks(f(g(h())))`.
func (c *PathClient) Use(hooks ...Hook) {
	c.hooks.Path = append(c.hooks.Path, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `path.Intercept(f(g(h())))`.
func (c *PathClient) Intercept(interceptors ...Interceptor) {
	c.inters.Path = append(c.inters.Path, interceptors...)
}

// Create returns a builder for creating a Path entity.
func (c *PathClient) Create() *PathCreate {
	mutation := newPathMutation(c.config, OpCreate)
	return &PathCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Path entities.
func (c *PathClient) CreateBulk(builders ...*PathCreate) *PathCreateBulk {
	return &PathCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PathClient) MapCreateBulk(slice any, setFunc func(*PathCreate, int)) *PathCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PathCreateBulk{err: fmt.Errorf("calling to PathClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PathCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PathCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Path.
func (c *PathClient) Update() *PathUpdate {
	mutation := newPathMutation(c.config, OpUpdate)
	return &PathUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PathClient) UpdateOne(pa *Path) *PathUpdateOne {
	mutation := newPathMutation(c.config, OpUpdateOne, withPath(pa))
	return &PathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PathClient) UpdateOneID(id int) *PathUpdateOne {
	mutation := newPathMutation(c.config, OpUpdateOne, withPathID(id))
	return &PathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Path.
func (c *PathClient) Delete() *PathDelete {
	mutation := newPathMutation(c.config, OpDelete)
	return &PathDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PathClient) DeleteOne(pa *Path) *PathDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PathClient) DeleteOneID(id int) *PathDeleteOne {
	builder := c.Delete().Where(path.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PathDeleteOne{builder}
}

// Query returns a query builder for Path.
func (c *PathClient) Query() *PathQuery {
	return &PathQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePath},
		inters: c.Interceptors(),
	}
}

// Get returns a Path entity by its id.
func (c *PathClient) Get(ctx context.Context, id int) (*Path, error) {
	return c.Query().Where(path.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PathClient) GetX(ctx context.Context, id int) *Path {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PathClient) Hooks() []Hook {
	return c.hooks.Path
}

// Interceptors returns the client interceptors.
func (c *PathClient) Interceptors() []Interceptor {
	return c.inters.Path
}

func (c *PathClient) mutate(ctx context.Context, m *PathMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PathCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PathUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PathUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PathDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Path mutation op: %q", m.Op())
	}
}

// RegistrarClient is a client for the Registrar schema.
type RegistrarClient struct {
	config
}

// NewRegistrarClient returns a client for the Registrar from the given config.
func NewRegistrarClient(c config) *RegistrarClient {
	return &RegistrarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `registrar.Hooks(f(g(h())))`.
func (c *RegistrarClient) Use(hooks ...Hook) {
	c.hooks.Registrar = append(c.hooks.Registrar, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `registrar.Intercept(f(g(h())))`.
func (c *RegistrarClient) Intercept(interceptors ...Interceptor) {
	c.inters.Registrar = append(c.inters.Registrar, interceptors...)
}

// Create returns a builder for creating a Registrar entity.
func (c *RegistrarClient) Create() *RegistrarCreate {
	mutation := newRegistrarMutation(c.config, OpCreate)
	return &RegistrarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Registrar entities.
func (c *RegistrarClient) CreateBulk(builders ...*RegistrarCreate) *RegistrarCreateBulk {
	return &RegistrarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RegistrarClient) MapCreateBulk(slice any, setFunc func(*RegistrarCreate, int)) *RegistrarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RegistrarCreateBulk{err: fmt.Errorf("calling to RegistrarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RegistrarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RegistrarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Registrar.
func (c *RegistrarClient) Update() *RegistrarUpdate {
	mutation := newRegistrarMutation(c.config, OpUpdate)
	return &RegistrarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RegistrarClient) UpdateOne(r *Registrar) *RegistrarUpdateOne {
	mutation := newRegistrarMutation(c.config, OpUpdateOne, withRegistrar(r))
	return &RegistrarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RegistrarClient) UpdateOneID(id int) *RegistrarUpdateOne {
	mutation := newRegistrarMutation(c.config, OpUpdateOne, withRegistrarID(id))
	return &RegistrarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Registrar.
func (c *RegistrarClient) Delete() *RegistrarDelete {
	mutation := newRegistrarMutation(c.config, OpDelete)
	return &RegistrarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RegistrarClient) DeleteOne(r *Registrar) *RegistrarDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RegistrarClient) DeleteOneID(id int) *RegistrarDeleteOne {
	builder := c.Delete().Where(registrar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RegistrarDeleteOne{builder}
}

// Query returns a query builder for Registrar.
func (c *RegistrarClient) Query() *RegistrarQuery {
	return &RegistrarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRegistrar},
		inters: c.Interceptors(),
	}
}

// Get returns a Registrar entity by its id.
func (c *RegistrarClient) Get(ctx context.Context, id int) (*Registrar, error) {
	return c.Query().Where(registrar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RegistrarClient) GetX(ctx context.Context, id int) *Registrar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RegistrarClient) Hooks() []Hook {
	return c.hooks.Registrar
}

// Interceptors returns the client interceptors.
func (c *RegistrarClient) Interceptors() []Interceptor {
	return c.inters.Registrar
}

func (c *RegistrarClient) mutate(ctx context.Context, m *RegistrarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RegistrarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RegistrarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RegistrarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RegistrarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Registrar mutation op: %q", m.Op())
	}
}

// ScanClient is a client for the Scan schema.
type ScanClient struct {
	config
}

// NewScanClient returns a client for the Scan from the given config.
func NewScanClient(c config) *ScanClient {
	return &ScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scan.Hooks(f(g(h())))`.
func (c *ScanClient) Use(hooks ...Hook) {
	c.hooks.Scan = append(c.hooks.Scan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scan.Intercept(f(g(h())))`.
func (c *ScanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Scan = append(c.inters.Scan, interceptors...)
}

// Create returns a builder for creating a Scan entity.
func (c *ScanClient) Create() *ScanCreate {
	mutation := newScanMutation(c.config, OpCreate)
	return &ScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Scan entities.
func (c *ScanClient) CreateBulk(builders ...*ScanCreate) *ScanCreateBulk {
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScanClient) MapCreateBulk(slice any, setFunc func(*ScanCreate, int)) *ScanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScanCreateBulk{err: fmt.Errorf("calling to ScanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Scan.
func (c *ScanClient) Update() *ScanUpdate {
	mutation := newScanMutation(c.config, OpUpdate)
	return &ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScanClient) UpdateOne(s *Scan) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScan(s))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScanClient) UpdateOneID(id int) *ScanUpdateOne {
	mutation := newScanMutation(c.config, OpUpdateOne, withScanID(id))
	return &ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Scan.
func (c *ScanClient) Delete() *ScanDelete {
	mutation := newScanMutation(c.config, OpDelete)
	return &ScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScanClient) DeleteOne(s *Scan) *ScanDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScanClient) DeleteOneID(id int) *ScanDeleteOne {
	builder := c.Delete().Where(scan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScanDeleteOne{builder}
}

// Query returns a query builder for Scan.
func (c *ScanClient) Query() *ScanQuery {
	return &ScanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScan},
		inters: c.Interceptors(),
	}
}

// Get returns a Scan entity by its id.
func (c *ScanClient) Get(ctx context.Context, id int) (*Scan, error) {
	return c.Query().Where(scan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScanClient) GetX(ctx context.Context, id int) *Scan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIpaddress queries the ipaddress edge of a Scan.
func (c *ScanClient) QueryIpaddress(s *Scan) *IPAddressQuery {
	query := (&IPAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.IpaddressTable, scan.IpaddressColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAsninfo queries the asninfo edge of a Scan.
func (c *ScanClient) QueryAsninfo(s *Scan) *ASNInfoQuery {
	query := (&ASNInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(asninfo.Table, asninfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.AsninfoTable, scan.AsninfoColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDnsentry queries the dnsentry edge of a Scan.
func (c *ScanClient) QueryDnsentry(s *Scan) *DNSEntryQuery {
	query := (&DNSEntryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(dnsentry.Table, dnsentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.DnsentryTable, scan.DnsentryColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDomain queries the domain edge of a Scan.
func (c *ScanClient) QueryDomain(s *Scan) *DomainQuery {
	query := (&DomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.DomainTable, scan.DomainColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPaths queries the paths edge of a Scan.
func (c *ScanClient) QueryPaths(s *Scan) *PathQuery {
	query := (&PathClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(path.Table, path.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.PathsTable, scan.PathsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNameserver queries the nameserver edge of a Scan.
func (c *ScanClient) QueryNameserver(s *Scan) *NameserverQuery {
	query := (&NameserverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(nameserver.Table, nameserver.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.NameserverTable, scan.NameserverColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegistrar queries the registrar edge of a Scan.
func (c *ScanClient) QueryRegistrar(s *Scan) *RegistrarQuery {
	query := (&RegistrarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(registrar.Table, registrar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.RegistrarTable, scan.RegistrarColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWhois queries the whois edge of a Scan.
func (c *ScanClient) QueryWhois(s *Scan) *WhoisQuery {
	query := (&WhoisClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scan.Table, scan.FieldID, id),
			sqlgraph.To(whois.Table, whois.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scan.WhoisTable, scan.WhoisColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScanClient) Hooks() []Hook {
	return c.hooks.Scan
}

// Interceptors returns the client interceptors.
func (c *ScanClient) Interceptors() []Interceptor {
	return c.inters.Scan
}

func (c *ScanClient) mutate(ctx context.Context, m *ScanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Scan mutation op: %q", m.Op())
	}
}

// WhoisClient is a client for the Whois schema.
type WhoisClient struct {
	config
}

// NewWhoisClient returns a client for the Whois from the given config.
func NewWhoisClient(c config) *WhoisClient {
	return &WhoisClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `whois.Hooks(f(g(h())))`.
func (c *WhoisClient) Use(hooks ...Hook) {
	c.hooks.Whois = append(c.hooks.Whois, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `whois.Intercept(f(g(h())))`.
func (c *WhoisClient) Intercept(interceptors ...Interceptor) {
	c.inters.Whois = append(c.inters.Whois, interceptors...)
}

// Create returns a builder for creating a Whois entity.
func (c *WhoisClient) Create() *WhoisCreate {
	mutation := newWhoisMutation(c.config, OpCreate)
	return &WhoisCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Whois entities.
func (c *WhoisClient) CreateBulk(builders ...*WhoisCreate) *WhoisCreateBulk {
	return &WhoisCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WhoisClient) MapCreateBulk(slice any, setFunc func(*WhoisCreate, int)) *WhoisCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WhoisCreateBulk{err: fmt.Errorf("calling to WhoisClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WhoisCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WhoisCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Whois.
func (c *WhoisClient) Update() *WhoisUpdate {
	mutation := newWhoisMutation(c.config, OpUpdate)
	return &WhoisUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WhoisClient) UpdateOne(w *Whois) *WhoisUpdateOne {
	mutation := newWhoisMutation(c.config, OpUpdateOne, withWhois(w))
	return &WhoisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WhoisClient) UpdateOneID(id int) *WhoisUpdateOne {
	mutation := newWhoisMutation(c.config, OpUpdateOne, withWhoisID(id))
	return &WhoisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Whois.
func (c *WhoisClient) Delete() *WhoisDelete {
	mutation := newWhoisMutation(c.config, OpDelete)
	return &WhoisDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WhoisClient) DeleteOne(w *Whois) *WhoisDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WhoisClient) DeleteOneID(id int) *WhoisDeleteOne {
	builder := c.Delete().Where(whois.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WhoisDeleteOne{builder}
}

// Query returns a query builder for Whois.
func (c *WhoisClient) Query() *WhoisQuery {
	return &WhoisQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWhois},
		inters: c.Interceptors(),
	}
}

// Get returns a Whois entity by its id.
func (c *WhoisClient) Get(ctx context.Context, id int) (*Whois, error) {
	return c.Query().Where(whois.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WhoisClient) GetX(ctx context.Context, id int) *Whois {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIprange queries the iprange edge of a Whois.
func (c *WhoisClient) QueryIprange(w *Whois) *IPAddressQuery {
	query := (&IPAddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(whois.Table, whois.FieldID, id),
			sqlgraph.To(ipaddress.Table, ipaddress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, whois.IprangeTable, whois.IprangeColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDomain queries the domain edge of a Whois.
func (c *WhoisClient) QueryDomain(w *Whois) *DomainQuery {
	query := (&DomainClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(whois.Table, whois.FieldID, id),
			sqlgraph.To(domain.Table, domain.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, whois.DomainTable, whois.DomainColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAsn queries the asn edge of a Whois.
func (c *WhoisClient) QueryAsn(w *Whois) *ASNInfoQuery {
	query := (&ASNInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(whois.Table, whois.FieldID, id),
			sqlgraph.To(asninfo.Table, asninfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, whois.AsnTable, whois.AsnColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegistrar queries the registrar edge of a Whois.
func (c *WhoisClient) QueryRegistrar(w *Whois) *RegistrarQuery {
	query := (&RegistrarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(whois.Table, whois.FieldID, id),
			sqlgraph.To(registrar.Table, registrar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, whois.RegistrarTable, whois.RegistrarColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNameservers queries the nameservers edge of a Whois.
func (c *WhoisClient) QueryNameservers(w *Whois) *NameserverQuery {
	query := (&NameserverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(whois.Table, whois.FieldID, id),
			sqlgraph.To(nameserver.Table, nameserver.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, whois.NameserversTable, whois.NameserversColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WhoisClient) Hooks() []Hook {
	return c.hooks.Whois
}

// Interceptors returns the client interceptors.
func (c *WhoisClient) Interceptors() []Interceptor {
	return c.inters.Whois
}

func (c *WhoisClient) mutate(ctx context.Context, m *WhoisMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WhoisCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WhoisUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WhoisUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WhoisDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("model_ent: unknown Whois mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ASNInfo, DNSEntry, Domain, IPAddress, Nameserver, Path, Registrar, Scan,
		Whois []ent.Hook
	}
	inters struct {
		ASNInfo, DNSEntry, Domain, IPAddress, Nameserver, Path, Registrar, Scan,
		Whois []ent.Interceptor
	}
)
